<!DOCTYPE html><html><head><link href="https://fonts.googleapis.com/css?family=Josefin+Sans" rel="stylesheet" type="text/css"></link><title>webgl-experiments</title><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><script src="js/@chap8.js"></script><link rel="stylesheet" type="text/css" href="css/dom.css"><script src="js/$.js"></script><script src="js/wdg.gl8.js"></script><script src="js/tfw.webgl.js"></script><script src="js/tfw.data-binding.js"></script><script src="js/tfw.listeners.js"></script><script src="js/polyfill.string.js"></script><script src="js/explosive-tp.js"></script><script src="js/dom.js"></script><script src="js/tfw.pointer-events.js"></script><script src="js/polyfill.classList.js"></script><script src="js/x-widget.js"></script><link rel="stylesheet" type="text/css" href="css/@chap8.css"></head><body class="theme-webgl theme-color-bg-B5"><section class="theme-color-bg-B0 theme-elevation-4"><h1 id="framebuffer">Framebuffer</h1>
<p>Jusqu&#39;à présent, nous avons toujours dessiné directement sur l&#39;écran, mais WebGL permet de faire du rendu dans des textures que l&#39;on peut réutiliser ensuite pour un nouvel affichage.</p>
<div id="wdg.gl80" style="display:none"></div><p>Dans l&#39;exemple ci-dessus, nous utilisons le code du chapitre précédent, mais le rendu se fait dans une texture. Ensuite, nous affichons un carré et utilisons le fragment shader suivant sur la texture :</p>
<pre class="custom highlight js">
    precision mediump float;
    
    <span class="comment">// La texture créée à l'aide d'un Frame Buffer
    </span>uniform sampler2D uniTexture;
    
    <span class="comment">// Les coordonnées de l'écran, comprises entre -1.0 et +1.0
    </span>varying vec2 varUV;
    <span class="comment">// Temps en millisecondes
    </span>varying float varTime;
    
    <span class="comment">// Constante utilisée pour lire les pixels avoisinants.
    </span>const float S <span class="operator">=</span> 1.0 <span class="operator">/</span> 128.0;
    
    <span class="comment">// La couleur fait-elle partie de l'arrière-plan ?
    </span><span class="comment">// En fait, on vérifie qu'elle est blanche, ou proche du blanc.
    </span>bool <span class="function">isBackground</span>(vec4 color) {
     <span class="keyword"> if</span> (color.r <span class="operator">&gt;</span> .9 <span class="operator">&amp;</span><span class="operator">&amp;</span> color.g <span class="operator">&gt;</span> .9 <span class="operator">&amp;</span><span class="operator">&amp;</span> color.b <span class="operator">&gt;</span> .9)<span class="keyword"> return</span> true;
     <span class="keyword"> return</span> false;
    }
    
    <span class="comment">// Effet 1 : on prend l'image telle qu'elle est.
    </span>void <span class="function">fx1</span>(vec4 color, float u, float v, float x, float y) {
      gl_FragColor <span class="operator">=</span> color;
    }
    
    <span class="comment">// Effet 2 : détextion de contour + seuil.
    </span>void <span class="function">fx2</span>(vec4 color, float u, float v, float x, float y) {
      gl_FragColor <span class="operator">=</span> color <span class="operator">*</span> 9.0
        <span class="operator">-</span> <span class="function">texture2D</span>( uniTexture, <span class="function">vec2</span>(u <span class="operator">-</span> S, v <span class="operator">-</span> S) )
        <span class="operator">-</span> <span class="function">texture2D</span>( uniTexture, <span class="function">vec2</span>(u    , v <span class="operator">-</span> S) )
        <span class="operator">-</span> <span class="function">texture2D</span>( uniTexture, <span class="function">vec2</span>(u <span class="operator">+</span> S, v <span class="operator">-</span> S) )
        <span class="operator">-</span> <span class="function">texture2D</span>( uniTexture, <span class="function">vec2</span>(u <span class="operator">-</span> S, v    ) )
        <span class="operator">-</span> <span class="function">texture2D</span>( uniTexture, <span class="function">vec2</span>(u <span class="operator">+</span> S, v    ) )
        <span class="operator">-</span> <span class="function">texture2D</span>( uniTexture, <span class="function">vec2</span>(u <span class="operator">-</span> S, v <span class="operator">+</span> S) )
        <span class="operator">-</span> <span class="function">texture2D</span>( uniTexture, <span class="function">vec2</span>(u    , v <span class="operator">+</span> S) )
        <span class="operator">-</span> <span class="function">texture2D</span>( uniTexture, <span class="function">vec2</span>(u <span class="operator">+</span> S, v <span class="operator">+</span> S) );
     <span class="keyword"> if</span> (gl_FragColor.r <span class="operator">+</span> gl_FragColor.g <span class="operator">+</span> gl_FragColor.b <span class="operator">&gt;</span> .1) {
       <span class="keyword"> if</span> (!<span class="function">isBackground</span>(color)) {
          gl_FragColor <span class="operator">=</span> <span class="function">vec4</span>(1.0, 0.9 <span class="operator">*</span> u, 0.0, 1.0);
        } 
      }<span class="keyword"> else</span> {
        gl_FragColor <span class="operator">=</span> <span class="function">vec4</span>(0.0, 0.0, 0.0, 1.0);
      }
    }
    
    <span class="comment">// Effet 3 : variation de couleur en fonction de la position.
    </span>void <span class="function">fx3</span>(vec4 color, float u, float v, float x, float y) {
     <span class="keyword"> if</span> (<span class="function">isBackground</span>(color)) gl_FragColor <span class="operator">=</span> color;
     <span class="keyword"> else</span> gl_FragColor <span class="operator">=</span> <span class="function">vec4</span>(1.0 <span class="operator">-</span> color.r <span class="operator">*</span> u, 1.0 <span class="operator">-</span> color.g <span class="operator">*</span> u <span class="operator">*</span> v, 1.0 <span class="operator">-</span> color.b <span class="operator">*</span> v, 1.0);
    }
    
    <span class="comment">// Effet 4 : autre effet. On peut faire varier les coefficients de
    </span><span class="comment">// 9 pixels utilisés, à condition que leur somme soit égale à 1.
    </span>void <span class="function">fx4</span>(vec4 color, float u, float v, float x, float y) {
      gl_FragColor <span class="operator">=</span> <span class="operator">-</span> color <span class="operator">*</span> 7.0
        <span class="operator">+</span> <span class="function">texture2D</span>( uniTexture, <span class="function">vec2</span>(u <span class="operator">-</span> S, v <span class="operator">-</span> S) )
        <span class="operator">+</span> <span class="function">texture2D</span>( uniTexture, <span class="function">vec2</span>(u    , v <span class="operator">-</span> S) )
        <span class="operator">+</span> <span class="function">texture2D</span>( uniTexture, <span class="function">vec2</span>(u <span class="operator">+</span> S, v <span class="operator">-</span> S) )
        <span class="operator">+</span> <span class="function">texture2D</span>( uniTexture, <span class="function">vec2</span>(u <span class="operator">-</span> S, v    ) )
        <span class="operator">+</span> <span class="function">texture2D</span>( uniTexture, <span class="function">vec2</span>(u <span class="operator">+</span> S, v    ) )
        <span class="operator">+</span> <span class="function">texture2D</span>( uniTexture, <span class="function">vec2</span>(u <span class="operator">-</span> S, v <span class="operator">+</span> S) )
        <span class="operator">+</span> <span class="function">texture2D</span>( uniTexture, <span class="function">vec2</span>(u    , v <span class="operator">+</span> S) )
        <span class="operator">+</span> <span class="function">texture2D</span>( uniTexture, <span class="function">vec2</span>(u <span class="operator">+</span> S, v <span class="operator">+</span> S) );
      float r <span class="operator">=</span> gl_FragColor.r;
      float g <span class="operator">=</span> gl_FragColor.g;
      float b <span class="operator">=</span> gl_FragColor.b;
     <span class="keyword"> if</span> (r <span class="operator">+</span> g <span class="operator">+</span> b <span class="operator">&lt;</span> 2.0) {
        gl_FragColor <span class="operator">=</span> <span class="function">vec4</span>( g, 0.0, 0.0, 1.0);
      }
    }
    
    <span class="keyword">
    void</span> <span class="function">main</span>() {
      float x <span class="operator">=</span> varUV.x;
      float y <span class="operator">=</span> varUV.y;
      <span class="comment">// Les coordonnées (u,v) sont comprises entre 0.0 et 1.0
    </span>  float u <span class="operator">=</span> (1.0 <span class="operator">+</span> x) <span class="operator">/</span> 2.0;
      float v <span class="operator">=</span> (1.0 <span class="operator">+</span> y) <span class="operator">/</span> 2.0;
      <span class="comment">// Mouvement du centre qui permet de séparer l'affichage en 4.
    </span>  float ang <span class="operator">=</span> varTime <span class="operator">*</span> 0.000314;
      float r <span class="operator">=</span> <span class="function">cos</span>(4581.15 <span class="operator">+</span> varTime <span class="operator">*</span> 0.000711);
      float cx <span class="operator">=</span> <span class="function">cos</span>(ang) <span class="operator">*</span> r;
      float cy <span class="operator">=</span> <span class="function">sin</span>(ang) <span class="operator">*</span> r;
    
      <span class="comment">// Voici comment on lit un pixel dans une texture.
    </span>  vec4 color <span class="operator">=</span> <span class="function">texture2D</span>( uniTexture, <span class="function">vec2</span>(u, v) );
      <span class="comment">// En fonction de la position du pixel courant par rapport
    </span>  <span class="comment">// au centre (cx, cy), on applique un effet ou un autre.
    </span> <span class="keyword"> if</span> (x <span class="operator">&lt;</span> cx) {
       <span class="keyword"> if</span> (y <span class="operator">&lt;</span> cy) {
          <span class="function">fx1</span>(color, u, v, x, y);
        }<span class="keyword"> else</span> {
          <span class="function">fx2</span>(color, u, v, x, y);
        }
      }<span class="keyword"> else</span> {
       <span class="keyword"> if</span> (y <span class="operator">&lt;</span> cy) {
          <span class="function">fx3</span>(color, u, v, x, y);
        }<span class="keyword"> else</span> {
          <span class="function">fx4</span>(color, u, v, x, y);
        }
      }
    }</pre><p>Voyons maintenant comment on utilise les Framebuffers.</p>
<p>IL faut commencer par créer un texture qui recevra les affichages : </p>
<pre class="custom highlight js">
    <span class="comment">// Réserver de la mémoire dans la carte graphique
    </span><span class="comment">// pour une texture.
    </span>var texture <span class="operator">=</span> gl.<span class="function">createTexture</span>();
    
    <span class="comment">// Définir cette texture comme texture courante.
    </span>gl.<span class="function">bindTexture</span>(gl.TEXTURE_2D, texture);
    
    <span class="comment">// Si on donne une coordonnée U (aussi appelée S) qui est inférieure à 0 
    </span><span class="comment">// ou supérieure à 1, on n'afiche rien, on ne répète pas la texture.
    </span>gl.<span class="function">texParameteri</span>(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    <span class="comment">// Même configuration pour la coordonnée V (aussi appelée T).
    </span>gl.<span class="function">texParameteri</span>(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    <span class="comment">// Pour passer d'une coordonnée (u, v) en float à des entiers (x, y)
    </span><span class="comment">// correspondant à un pixel de l'image, on décide de ne pas interpoler,
    </span><span class="comment">// mais plutôt de prendre le pixel le plus proche (NEAREST en anglais).
    </span>gl.<span class="function">texParameteri</span>(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.<span class="function">texParameteri</span>(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    
    <span class="comment">// Initialisons les données de cette texture en spécifiant sa taille
    </span><span class="comment">// 512x512.
    </span>gl.<span class="function">texImage2D</span>(
        gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0,
        gl.RGBA, gl.UNSIGNED_BYTE, null);</pre><p>Ensuite, il faut créer un <strong>Framebuffer</strong> :</p>
<pre class="custom highlight js">
    <span class="comment">// Réserver de l'espace mémoire sur la carte graphique
    </span><span class="comment">// pour un nouveau Framebuffer.
    </span>var fb <span class="operator">=</span> gl.<span class="function">createFramebuffer</span>();
    <span class="comment">// Définer `fb` comme le Framebuffer courant.
    </span>gl.<span class="function">bindFramebuffer</span>(gl.FRAMEBUFFER, fb);
    <span class="comment">// Associer ce Framebuffer à la 
    </span><span class="comment">// texture précédemment créée.
    </span>gl.<span class="function">framebufferTexture2D</span>(
        gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, 
        gl.TEXTURE_2D, texture, 0);</pre><p>Le code du rendu ressemblera alors à cela :</p>
<pre class="custom highlight js">
    <span class="comment">// Tout ce qui suit sera rendu dans la texture.
    </span>gl.<span class="function">bindFramebuffer</span>( gl.FRAMEBUFFER, fb );
    ...
    
    <span class="comment">// Tout ce qui suit sera rendu dans le canvas.
    </span>gl.<span class="function">bindFramebuffer</span>( gl.FRAMEBUFFER, null );
    <span class="comment">// Dans le fragment shader, le premier `uniform`
    </span><span class="comment">// de type `sampler2D` recevra la texture `texture`.
    </span>gl.<span class="function">bindTexture</span>( gl.TEXTURE_2D, texture );
    ...</pre><h2 id="plus-de-d-tails">Plus de détails</h2>
<ul>
<li><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texImage2D"><strong><code>gl.texImage2D(target, level, internalformat, width, height, border, format, type, pixels)</code></strong></a></p>
<ul>
<li><strong>target</strong> : généralement <code>gl.TEXTURE_2D</code>, sauf si vous voulez des textures 3D.</li>
<li><strong>level</strong> : niveau de détail. Généralement 0.</li>
<li><strong>internalformat</strong> : définit le fomat de stockage des pixels dans la texture. Généralement <code>gl.RGBA</code>, <code>gl.RGB</code> ou <code>gl.ALPHA</code>.</li>
<li><strong>width</strong> : largeur en pixels.</li>
<li><strong>height</strong> : hauteur en pixels.</li>
<li><strong>border</strong> : épaisseur de la bordure. Généralement 0.</li>
<li><strong>format</strong> : Généralement, mettre la même chose que dans <strong>internalformat</strong>.</li>
<li><strong>type</strong> : permet de compresser les données. Généralement <code>gl.UNSIGNED_BYTE</code>.</li>
<li><strong>pixels</strong> : peut être une image ou un tableau de pixels. Mais dans notre cas, on n&#39;initialise par, donc <code>null</code>.</li>
</ul>
</li>
<li><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/framebufferTexture2D"><strong><code>framebufferTexture2D(target, attachment, textarget, texture, level)</code></strong></a></p>
<ul>
<li><strong>target</strong> : Généralement <code>gl.FRAMEBUFFER</code>.</li>
<li><strong>attachment</strong> : les trois valeurs les plus importantes sont :<ul>
<li><strong>gl.COLOR_ATTACHMENT0</strong> : stoquer la couleur des pixels dans la texture cible.</li>
<li><strong>gl.DEPTH_ATTACHMENT</strong> : stoquer le Z-buffer dans la texture cible. C&#39;est-à-dire la coordonnée <strong>Z</strong> de chaque pixel.</li>
<li><strong>gl.STENCIL_ATTACHMENT</strong> : stoquer le <em>stencil</em> dans la texture cible. Nous verrons cela dans un prochain chapitre.</li>
</ul>
</li>
<li><strong>textarget</strong> : type de la texture cible. Généralement <code>gl.TEXTURE_2D</code>.</li>
<li><strong>texture</strong> : la texture cible.</li>
<li><strong>level</strong> : Généralement 0.</li>
</ul>
</li>
</ul>
<h2 id="a-quoi-peut-bien-servir-de-stoquer-le-z-buffer-">A quoi peut bien servir de stoquer le Z-buffer ?</h2>
<p>Vous avez certainement déjà joué à des jeux 3D dans lesquels le personnage passe parfois derrière un élément du décor. Pour éviter de rendre le joueur aveugle, une astuce consiste à afficher l&#39;ombre du personnage en surimpression des éléments qui font obstacle à la caméra.</p>
<p>En stoquant le <strong>depth buffer</strong> (<code>gl.DEPTH_ATTACHMENT</code>) du décor et celui du personnage, il est ensuite de redessiner le personnage en comparant les pixels dans ces deux textures. Je vous laisse réfléchir aux détail, mais ce n&#39;est pas trop difficile maintenant que vous savez utiliser les Framebuffers et les textures.</p>
<hr>
<ul>
<li>Chapitre précédent : <a href="chap7.html">Particules</a>.</li>
</ul>
</section><nav class="theme-color-bg-B2 theme-elevation-2"><p> Sommaire :</p>
<ul>
<li><a href="index.html">Comprendre WebGL</a></li>
<li><a href="chap1.html">Changer le système de coordonnées 2D</a></li>
<li><a href="chap2.html">Vivent les polygones</a></li>
<li><a href="chap3.html">Textures procédurales</a></li>
<li><a href="chap4.html">Animations</a></li>
<li><a href="chap5.html">Textures bitmaps</a></li>
<li><a href="chap6.html">Un point c&#39;est tout</a></li>
<li><a href="chap7.html">Particules</a></li>
<li><a href="chap8.html">Framebuffer</a></li>
</ul>

</nav></body></html>