<!DOCTYPE html><html><head><link href="https://fonts.googleapis.com/css?family=Josefin+Sans" rel="stylesheet" type="text/css"></link><title>webgl-experiments</title><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><script src="js/@chap7.js"></script><link rel="stylesheet" type="text/css" href="css/dom.css"><script src="js/$.js"></script><script src="js/wdg.gl7.js"></script><script src="js/tfw.data-binding.js"></script><script src="js/tfw.listeners.js"></script><script src="js/polyfill.string.js"></script><script src="js/dom.js"></script><script src="js/tfw.pointer-events.js"></script><script src="js/polyfill.classList.js"></script><script src="js/x-widget.js"></script><link rel="stylesheet" type="text/css" href="css/@chap7.css"></head><body class="theme-webgl theme-color-bg-B5"><section class="theme-color-bg-B0 theme-elevation-4"><h1 id="particules">Particules</h1>
<p>Les particules sont en réalité des nuées de points qui peuvent servir à représenter de la fumnée, du feu, de l&#39;eau et tout ce que votre imagination peut créer.</p>
<div id="wdg.gl768" style="display:none"></div><p>Pour que l&#39;affichage des particules soit efficace, il faut placer toute la logique dans les shaders. Voici à quoi est réduite la boucle de rendu en Javascript :</p>
<pre class="custom highlight js">
    gl.<span class="function">clearColor</span>(1.0, 1.0, 1.0, 1.0);
        gl.<span class="function">bindBuffer</span>(gl.ARRAY_BUFFER, bufAttributes);
    
       <span class="keyword"> function</span> <span class="function">render</span>(time) {
           <span class="keyword2"> window</span>.<span class="function">requestAnimationFrame</span>( render );
    
            gl.<span class="function">clear</span>(gl.COLOR_BUFFER_BIT);
            gl.<span class="function">uniform1f</span>(uniTime, time);
            gl.<span class="function">drawArrays</span>(gl.POINTS, 0, count);
        }
       <span class="keyword2"> window</span>.<span class="function">requestAnimationFrame</span>( render );</pre><p>La seule donnée variable est <code>uniTime</code> et le <em>vertex shader</em> se base sur cette variable pour calculer la position, la taille et la couleur du vertex, donc de la particule.</p>
<pre class="custom highlight js">
    <span class="comment">// Temps courant en millisecondes
    </span>uniform float uniTime;
    
    <span class="comment">// Position en valeurs comprises entre -1.0 et +1.0
    </span>attribute vec2 attPosition;
    <span class="comment">// 4 Valeurs aléatoires comprises entre 0.0 et 1.0
    </span><span class="comment">// Ces valeurs donnent la "personnalité" de la particule
    </span>attribute vec4 attRandom;
    
    <span class="comment">// Couleur pour le fragment shader
    </span>varying vec3 varColor;
    <span class="comment">// Indique au fragment shader si les particules sont
    </span><span class="comment">// en place (1.0) ou en mouvement désordonné (0.0)
    </span>varying float varCoeff;
    <span class="keyword">
    void</span> <span class="function">main</span>() {
      float t <span class="operator">=</span> <span class="function">dot</span>(attRandom, attRandom) <span class="operator">*</span> 10000.0 <span class="operator">+</span> uniTime <span class="operator">/</span> 100.0;
      <span class="comment">// Position "en place" de la particule.
    </span>  float x <span class="operator">=</span> attPosition.x;
      float y <span class="operator">=</span> attPosition.y;
    
      <span class="comment">// Créer un léger mouvement autour de la position normale.
    </span>  float radius <span class="operator">=</span> .02 <span class="operator">*</span> <span class="function">cos</span>(t <span class="operator">*</span> attRandom.y);
      float ang <span class="operator">=</span> uniTime <span class="operator">*</span> attRandom.z <span class="operator">/</span> 100.0;
      x <span class="operator">=</span> x <span class="operator">+</span> radius <span class="operator">*</span> <span class="function">cos</span>(ang);
      y <span class="operator">=</span> y <span class="operator">+</span> radius <span class="operator">*</span> <span class="function">sin</span>(ang);
    
      <span class="comment">// Coordonnées aléatoires en rotation dans tout l'espace.
    </span>  radius <span class="operator">=</span> 1.5 <span class="operator">*</span> <span class="function">sin</span>(t <span class="operator">*</span> 0.01 <span class="operator">*</span> (attRandom.y <span class="operator">+</span> attRandom.x));
      ang <span class="operator">=</span> t <span class="operator">*</span> attRandom.x <span class="operator">*</span> 0.1;
      float xx <span class="operator">=</span> radius <span class="operator">*</span> <span class="function">cos</span>(ang);
      float yy <span class="operator">=</span> radius <span class="operator">*</span> <span class="function">sin</span>(ang);
    
      <span class="comment">// Dans un cycle de 12 secondes, l'image est stable
    </span>  <span class="comment">// pendant 8 secondes et en vrac pendant 4.
    </span>  float c1 <span class="operator">=</span> 0.0;
      float tt <span class="operator">=</span> <span class="function">mod</span>(uniTime, 12000.0);
     <span class="keyword"> if</span> (tt <span class="operator">&lt;</span> 4000.0) {
        c1 <span class="operator">=</span> <span class="function">sin</span>(tt <span class="operator">*</span> 3.1415926539 <span class="operator">/</span> 4000.0);
      }
      float c2 <span class="operator">=</span> 1.0 <span class="operator">-</span> c1;
    
      varCoeff <span class="operator">=</span> c2;
      <span class="comment">// Petites variations de vert.
    </span>  varColor <span class="operator">=</span> <span class="function">vec3</span>( 0.0, .3 <span class="operator">+</span> .1 <span class="operator">*</span> <span class="function">abs</span>(<span class="function">cos</span>(attRandom.x <span class="operator">*</span> uniTime <span class="operator">*</span> 0.01)), 0.0 );
      <span class="comment">// La position est intrerpolée entre (x,y) et (xx,yy).
    </span>  gl_Position <span class="operator">=</span> <span class="function">vec4</span>( x <span class="operator">*</span> c2 <span class="operator">+</span> xx <span class="operator">*</span> c1, y <span class="operator">*</span> c2 <span class="operator">+</span> yy <span class="operator">*</span> c1, 0.0, 1.0 );
      <span class="comment">// Palpitation de la taille et diminution lors de la phase de désordre.
    </span>  ang <span class="operator">=</span> t <span class="operator">*</span> attRandom.x;
      gl_PointSize <span class="operator">=</span> <span class="function">max</span>(8.0, (32.0 <span class="operator">+</span> 8.0 <span class="operator">*</span> <span class="function">cos</span>(ang)) <span class="operator">*</span> (.5 <span class="operator">+</span> c2 <span class="operator">*</span> .5));
    }</pre><p>Le <em>fragment shader</em> va dessiner des cercles dont le centre à la couleur <code>varColor</code> et qui devient de plus en plus transparent en allant vers la périphérie. A chaque affichage de particule, il faut que la transparence laisse voir ce qui est déjà à l&#39;écran. Ceci est réalisé par le <strong>blending</strong>. Le code qui donne la bonne configuration pour notre démonstration est le suivant :</p>
<pre class="custom highlight js">
    gl.<span class="function">disable</span>(gl.DEPTH_TEST);
        gl.<span class="function">enable</span>(gl.BLEND);
        gl.<span class="function">blendFuncSeparate</span>(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ZERO, gl.ONE);
        gl.<span class="function">blendEquation</span>(gl.FUNC_ADD);</pre><p>Les 4 arguments de la fonction <code>blendFuncSeparate()</code> sont tous des énumérés dont voici les valeurs :</p>
<pre>
 Valeur                | Red, Green, Blue  | Alpha
-----------------------+-------------------+-------
gl.ZERO                | 0,0,0             | 0
gl.ONE                 | 1,1,1             | 1
gl.SRC_COLOR           | Rs, Gs, Bs        | As
gl.ONE_MINUS_SRC_COLOR | 1-Rs, 1-Gs, 1-Bs  | 1-As
gl.DST_COLOR           | Rd, Gd, Bd        | Ad
gl.ONE_MINUS_DST_COLOR | 1-Rd, 1-Gd, 1-Bd  | 1-Ad
gl.SRC_ALPHA           | As, As, As        | As
gl.ONE_MINUS_SRC_ALPHA | 1-Ad, 1-Ad, 1-Ad  | 1-As
gl.DST_ALPHA           | Ad, Ad, Ad        | Ad
gl.ONE_MINUS_DST_ALPHA | 1-Ad, 1-Ad, 1-Ad  | 1-Ad
gl.SRC_ALPHA_SATURATE  | min(As, 1 - Ad),  |
                       | min(As, 1 - Ad),  | 1
                       | min(As, 1 - Ad)   | 
</pre><p>On appelle <strong>source</strong> la couleur qui résulte du <em>fragment shader</em> et qui est dans la variable <code>gl_FragColor</code>. Et on appelle <strong>destination</strong> la couleur qui est actuellement affichée.</p>
<ul>
<li>La <strong>source</strong> a 4 composantes : <code>(Rs, Gs, Bs, As)</code>.</li>
<li>La <strong>destination</strong> a 4 composantes : <code>(Rd, Gd, Bd, Ad)</code>.</li>
</ul>
<p>La fonction <strong>blendFuncSeparate()</strong> a les arguments suivants :</p>
<ul>
<li>Coefficient à multiplier avec <code>(Rs, Gs, Bs)</code>.</li>
<li>Coefficient à multiplier avec <code>(Rd, Gd, Bd)</code>.</li>
<li>Coefficient à multiplier avec <code>(As)</code>.</li>
<li>Coefficient à multiplier avec <code>(Ad)</code>.</li>
</ul>
<p>Le code <code>gl.blendEquation(gl.FUNC_ADD)</code> indique qu&#39;il faut ensuite additionner les deux couleurs résultantes.</p>
<p>On en déduit que, dans notre exemple, on obtiendra ceci :</p>
<pre>
Red   := Rs * As + Rd * (1 - As)
Green := Gs * As + Gd * (1 - As)
Blue  := Bs * As + Bd * (1 - As)
Alpha := As * 0 + Ad * 1
</pre><p>Une fois bien compris, le blending est un outil puissant qui permet de réaliser de nombreux effets.</p>
<hr/><ul>
<li>Chapitre précédent : <a href="chap6.html">Un point c&#39;est tout</a>.</li>
<li>Chapitre suivant : <a href="chap8.html">Framebuffer</a>.</li>
</ul>
</section><nav class="theme-color-bg-B2 theme-elevation-2"><p> Sommaire :</p>
<ul>
<li><a href="index.html">Comprendre WebGL</a></li>
<li><a href="chap1.html">Changer le système de coordonnées 2D</a></li>
<li><a href="chap2.html">Vivent les polygones</a></li>
<li><a href="chap3.html">Textures procédurales</a></li>
<li><a href="chap4.html">Animations</a></li>
<li><a href="chap5.html">Textures bitmaps</a></li>
<li><a href="chap6.html">Un point c&#39;est tout</a></li>
<li><a href="chap7.html">Particules</a></li>
<li><a href="chap8.html">Framebuffer</a></li>
</ul>

</nav></body></html>