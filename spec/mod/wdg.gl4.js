require("wdg.gl4",function(r,n){function e(){return h(f,arguments)}function t(r){function n(e){i.uniform1f(d,r.width),i.uniform1f(x,r.height),i.uniform1f(g,e),i.uniform1f(m,e),i.clearColor(0,0,0,0),i.clear(i.COLOR_BUFFER_BIT|i.DEPTH_BUFFER_BIT),i.drawArrays(i.TRIANGLE_STRIP,0,4),window.requestAnimationFrame(n)}var e=c.vertex,t=c["fragment-"+this.fragment],i=r.getContext("webgl")||r.getContext("experimental-webgl"),f=i.createProgram();i.attachShader(f,a(i,e)),i.attachShader(f,o(i,t)),i.linkProgram(f),i.useProgram(f);var h=i.createBuffer();i.bindBuffer(i.ARRAY_BUFFER,h);var s=r.width,u=r.height;i.bufferData(i.ARRAY_BUFFER,new Float32Array([0,0,0,s,0,0,0,u,0,s,u,0]),i.STATIC_DRAW),i.bindBuffer(i.ARRAY_BUFFER,h);var l=i.getAttribLocation(f,"attVertexPosition");i.enableVertexAttribArray(l),i.vertexAttribPointer(l,3,i.FLOAT,!1,0,0);var g=i.getUniformLocation(f,"uniTimeV"),m=i.getUniformLocation(f,"uniTimeF"),d=i.getUniformLocation(f,"uniWidth"),x=i.getUniformLocation(f,"uniHeight");window.requestAnimationFrame(n)}function i(r,n,e){var t=n.createShader(r);return n.shaderSource(t,e),n.compileShader(t),n.getShaderParameter(t,n.COMPILE_STATUS)?t:(console.log(e),console.error("An error occurred compiling the shader: "+n.getShaderInfoLog(t)),null)}function o(r,n){return i(r.FRAGMENT_SHADER,r,n)}function a(r,n){return i(r.VERTEX_SHADER,r,n)}var f={en:{}},h=require("$").intl,s=require("dom"),u=require("tfw.data-binding"),l=function(r){var n=s.elem(this,"canvas");u.propInteger(this,"width")(function(r){n.setAttribute("width",r),n.style.width=r+"px"}),u.propInteger(this,"height")(function(r){n.setAttribute("height",r),n.style.height=r+"px"}),u.propString(this,"fragment"),r=u.extend({width:640,height:480,fragment:"a"},r,this),window.setTimeout(t.bind(this,n),20)};n.exports=l;var c={vertex:"attribute vec3 attVertexPosition;\r\n\r\nuniform float uniWidth;\r\nuniform float uniHeight;\r\n\r\nuniform lowp float uniTimeV;\r\n\r\nvarying lowp vec3 varVertexPosition;\r\n\r\nvoid main() {\r\n  highp float time = uniTimeV;\r\n\r\n  varVertexPosition = attVertexPosition;\r\n  \r\n  float x = attVertexPosition.x;\r\n  float y = attVertexPosition.y;\r\n\r\n  x = (2.0 * x / uniWidth) - 1.0;\r\n  y = 1.0 - (2.0 * y / uniHeight);\r\n\r\n  float speed = 0.0;\r\n\r\n  if (x < 0.0) {\r\n    if (y < 0.0) {\r\n      speed = 1600.0;\r\n    } else {\r\n      speed = 1643.0;\r\n    }\r\n  } else {\r\n    if (y < 0.0) {\r\n      speed = 1703.0;\r\n    } else {\r\n      speed = 1742.0;\r\n    }\r\n  }\r\n\r\n  float radius = 0.5 + (cos(time / speed) + 1.0) / 4.0;\r\n  gl_Position = vec4( x * radius, y * radius, 0.0, 1.0 );\r\n}\r\n","fragment-a":"const highp float PI = 3.1415926539;\r\nconst lowp vec3 COLOR0 = vec3(0.7, 0.9, 1.0);\r\nconst lowp vec3 COLOR1 = vec3(0.0, 0.7, 0.9);\r\n\r\nvarying lowp vec3 varVertexPosition;\r\n\r\nuniform lowp float uniTimeF;\r\n\r\nvoid main() {\r\n  highp float time = uniTimeF / 700.0;\r\n  \r\n  lowp float x = varVertexPosition.x + time * 120.0;\r\n  lowp float y = varVertexPosition.y + sin(time) * 15.0;\r\n  \r\n  lowp float xx = x / 10.0;\r\n  lowp float yy = y / 10.0;\r\n  \r\n  lowp float h = cos(yy) * cos(xx) + sin(yy);\r\n  h = cos( PI * h + time);\r\n  \r\n  h = (1.0 + h) / 2.0;\r\n  gl_FragColor = vec4( h * COLOR0 + (1.0 - h) * COLOR1, 1.0);\r\n}\r\n"};n.exports._=e});
//# sourceMappingURL=wdg.gl4.js.map