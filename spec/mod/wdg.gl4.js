require("wdg.gl4",function(n,e){function t(){return h(f,arguments)}function i(n){function e(t){r.uniform1f(d,n.width),r.uniform1f(x,n.height),r.uniform1f(g,t),r.uniform1f(m,t),r.clearColor(0,0,0,0),r.clear(r.COLOR_BUFFER_BIT|r.DEPTH_BUFFER_BIT),r.drawArrays(r.TRIANGLE_STRIP,0,4),window.requestAnimationFrame(e)}var t=c.vertex,i=c["fragment-"+this.fragment],r=n.getContext("webgl")||n.getContext("experimental-webgl"),f=r.createProgram();r.attachShader(f,a(r,t)),r.attachShader(f,o(r,i)),r.linkProgram(f),r.useProgram(f);var h=r.createBuffer();r.bindBuffer(r.ARRAY_BUFFER,h);var s=n.width,u=n.height;r.bufferData(r.ARRAY_BUFFER,new Float32Array([0,0,0,s,0,0,0,u,0,s,u,0]),r.STATIC_DRAW),r.bindBuffer(r.ARRAY_BUFFER,h);var l=r.getAttribLocation(f,"attVertexPosition");r.enableVertexAttribArray(l),r.vertexAttribPointer(l,3,r.FLOAT,!1,0,0);var g=r.getUniformLocation(f,"uniTimeV"),m=r.getUniformLocation(f,"uniTimeF"),d=r.getUniformLocation(f,"uniWidth"),x=r.getUniformLocation(f,"uniHeight");window.requestAnimationFrame(e)}function r(n,e,t){var i=e.createShader(n);return e.shaderSource(i,t),e.compileShader(i),e.getShaderParameter(i,e.COMPILE_STATUS)?i:(console.log(t),console.error("An error occurred compiling the shader: "+e.getShaderInfoLog(i)),null)}function o(n,e){return r(n.FRAGMENT_SHADER,n,e)}function a(n,e){return r(n.VERTEX_SHADER,n,e)}var f={en:{}},h=require("$").intl,s=require("dom"),u=require("tfw.data-binding"),l=function(n){var e=s.elem(this,"canvas");u.propInteger(this,"width")(function(n){e.setAttribute("width",n),e.style.width=n+"px"}),u.propInteger(this,"height")(function(n){e.setAttribute("height",n),e.style.height=n+"px"}),u.propString(this,"fragment"),n=u.extend({width:640,height:480,fragment:"a"},n,this),window.setTimeout(i.bind(this,e),20)};e.exports=l;var c={vertex:"attribute vec3 attVertexPosition;\n\nuniform float uniWidth;\nuniform float uniHeight;\n\nuniform lowp float uniTimeV;\n\nvarying lowp vec3 varVertexPosition;\n\nvoid main() {\n  highp float time = uniTimeV;\n\n  varVertexPosition = attVertexPosition;\n  \n  float x = attVertexPosition.x;\n  float y = attVertexPosition.y;\n\n  x = (2.0 * x / uniWidth) - 1.0;\n  y = 1.0 - (2.0 * y / uniHeight);\n\n  float speed = 0.0;\n\n  if (x < 0.0) {\n    if (y < 0.0) {\n      speed = 1600.0;\n    } else {\n      speed = 1643.0;\n    }\n  } else {\n    if (y < 0.0) {\n      speed = 1703.0;\n    } else {\n      speed = 1742.0;\n    }\n  }\n\n  float radius = 0.5 + (cos(time / speed) + 1.0) / 4.0;\n  gl_Position = vec4( x * radius, y * radius, 0.0, 1.0 );\n}\n","fragment-a":"const highp float PI = 3.1415926539;\nconst lowp vec3 COLOR0 = vec3(0.7, 0.9, 1.0);\nconst lowp vec3 COLOR1 = vec3(0.0, 0.7, 0.9);\n\nvarying lowp vec3 varVertexPosition;\n\nuniform lowp float uniTimeF;\n\nvoid main() {\n  highp float time = uniTimeF / 700.0;\n  \n  lowp float x = varVertexPosition.x + time * 120.0;\n  lowp float y = varVertexPosition.y + sin(time) * 15.0;\n  \n  lowp float xx = x / 10.0;\n  lowp float yy = y / 10.0;\n  \n  lowp float h = cos(yy) * cos(xx) + sin(yy);\n  h = cos( PI * h + time);\n  \n  h = (1.0 + h) / 2.0;\n  gl_FragColor = vec4( h * COLOR0 + (1.0 - h) * COLOR1, 1.0);\n}\n"};e.exports._=t});
//# sourceMappingURL=wdg.gl4.js.map