require("wdg.gl6",function(e,n,r){function t(e){function n(e){var t,a,i,l,u=e/566,f=Math.cos(u),g=Math.sin(u),v=e/979,h=Math.cos(v),p=Math.sin(v),A=f,b=g,_=g*p,m=h,E=-f*p,P=-g*h,C=p,R=f*h;for(l=0;l<s;l++)t=c[3*l+0],a=c[3*l+1],i=c[3*l+2],d[6*l+0]=t*A+0*a+i*b,d[6*l+1]=t*_+a*m+i*E,d[6*l+2]=t*P+a*C+i*R;r.bindBuffer(r.ARRAY_BUFFER,o),r.bufferData(r.ARRAY_BUFFER,d,r.STATIC_DRAW),r.clear(r.COLOR_BUFFER_BIT),r.drawArrays(r.POINTS,0,s),window.requestAnimationFrame(n)}var r=e.getContext("webgl",{alpha:!1,depth:this.zbuffer,stencil:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,failIfMajorPerformanceCaveat:!0}),t=r.createProgram();r.attachShader(t,i(r,u.vertex)),r.attachShader(t,a(r,u.fragment)),r.linkProgram(t),r.useProgram(t);var o=r.createBuffer();r.bindBuffer(r.ARRAY_BUFFER,o);var s=6,d=new Float32Array(36);r.bufferData(r.ARRAY_BUFFER,d,r.STATIC_DRAW);var c=[1,0,0,-1,0,0,0,1,0,0,-1,0,0,0,1,0,0,-1];l[f];for(var g,v=0;v<s;v++)g=f[v],d[6*v+3]=.5*g[0],d[6*v+4]=.5*g[1],d[6*v+5]=.5*g[2];var h=d.BYTES_PER_ELEMENT,p=6*h,A=r.getAttribLocation(t,"attPosition");r.enableVertexAttribArray(A),r.vertexAttribPointer(A,3,r.FLOAT,!1,p,0);var b=r.getAttribLocation(t,"attColor");r.enableVertexAttribArray(b),r.vertexAttribPointer(b,3,r.FLOAT,!1,p,3*h),Boolean(this.zbuffer)?(r.enable(r.DEPTH_TEST),r.depthFunc(r.LEQUAL),r.disable(r.BLEND),r.enable(r.BLEND),r.blendFunc(r.SRC_ALPHA,r.ONE_MINUS_SRC_ALPHA)):(r.enable(r.BLEND),r.blendFunc(r.SRC_ALPHA,r.ONE_MINUS_SRC_ALPHA),r.disable(r.DEPTH_TEST)),r.clearColor(1,1,1,1),r.bindBuffer(r.ARRAY_BUFFER,o),window.requestAnimationFrame(n)}function o(e,n,r){var t=n.createShader(e);return n.shaderSource(t,r),n.compileShader(t),n.getShaderParameter(t,n.COMPILE_STATUS)?t:(console.log(r),console.error("An error occurred compiling the shader: "+n.getShaderInfoLog(t)),null)}function a(e,n){return o(e.FRAGMENT_SHADER,e,n)}function i(e,n){return o(e.VERTEX_SHADER,e,n)}function l(e){var n,r,t;for(n=0;n<e.length;n++)r=Math.floor(Math.random(e.length)),t=e[r],e[r]=e[n],e[n]=t;return e}var s=function(){function n(){return t(r,arguments)}var r={en:{}},t=e("$").intl;return n.all=r,n}(),u={vertex:"attribute vec3 attPosition;\nattribute vec3 attColor;\n\nvarying vec3 varPosition;\nvarying vec3 varColor;\n\nvoid main() {\n  float z = attPosition.z;\n  // Dans une projection 3D, les points éloignés de la caméra\n  // paraissent plus petits et plus proches les uns des autres.\n  // Cette variable permet de créer cet effet.\n  float depth = 3.0 / (2.0 - z);\n  // On utilise la 4ème composant `w` pour donner un effet de profndeur.\n  // En effet, les coordonnées seront multipliées/divisées par `depth`.\n  gl_Position = vec4(attPosition.xy, z, depth);\n\n  // La taille du point dépend aussi de la profondeur.\n  gl_PointSize = 150.0 / depth;\n  varPosition = attPosition;\n  varColor = attColor;\n}\n",fragment:"precision mediump float;\n\nvarying vec3 varPosition;\nvarying vec3 varColor;\n\nconst vec3 WHITE = vec3(1, 1, 1);\n\nvoid main() {\n  // Calculons la distance du fragment courant\n  // au centre du point.\n  float x = gl_PointCoord.x - 0.5;\n  float y = gl_PointCoord.y - 0.5;\n  // On ne calcule pas la racine carré pour gagner du temps.\n  float r = x*x + y*y;\n\n  x = gl_PointCoord.x;\n  y = gl_PointCoord.y;\n\n  // 0.25 = 0.5 * 0.5\n  if (r > 0.25) {\n    // Si on est à l'extérieur du cercle de rayon 0.5,\n    // on ignore le fragment.\n    discard;\n  } else if (r > .2 ) {\n    // Au delà d'un certain rayon, on met une couleur fixe\n    // qui nous sert de liseré.\n    gl_FragColor = vec4(varColor * 0.5, 1.0);\n  } else {\n    // Petit effet de dégradé.\n    vec3 col = x * varColor + y * WHITE.rgb;\n    gl_FragColor.a = 1.0;\n    gl_FragColor.rgb = mix(WHITE, varColor, r * 5.0);\n  }\n  // La luminosité varie avec la profondeur du point.\n  // En `z = 0.0`, la boule est noire.\n  float coeff = (1.0 - varPosition.z) * 0.5;\n  gl_FragColor.rgb = coeff * gl_FragColor.rgb;\n}\n"},d=e("dom"),c=e("tfw.data-binding"),f=[[2,0,0],[0,2,0],[0,0,2],[2,1,0],[2,0,1],[1,2,0],[0,2,1],[1,0,2],[0,1,2],[0,2,2],[2,0,2],[2,2,0]],g=function(e){var n=d.elem(this,"canvas");c.propInteger(this,"width")(function(e){n.setAttribute("width",e),n.style.width=e+"px"}),c.propInteger(this,"height")(function(e){n.setAttribute("height",e),n.style.height=e+"px"}),c.propBoolean(this,"zindex"),e=c.extend({width:640,height:480,zbuffer:!1},e,this),window.setTimeout(t.bind(this,n),20)};n.exports=g,n.exports._=s});
//# sourceMappingURL=wdg.gl6.js.map