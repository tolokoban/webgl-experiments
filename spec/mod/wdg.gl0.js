<<<<<<< HEAD
require("wdg.gl0",function(e,t){function r(){return s(o,arguments)}function n(e,t,r){var n=t.createShader(e);return t.shaderSource(n,r),t.compileShader(n),t.getShaderParameter(n,t.COMPILE_STATUS)?n:(console.log(r),console.error("An error occurred compiling the shader: "+t.getShaderInfoLog(n)),null)}function a(e,t){return n(e.FRAGMENT_SHADER,e,t)}function i(e,t){return n(e.VERTEX_SHADER,e,t)}var o={en:{}},s=require("$").intl,l=require("dom"),u=require("tfw.data-binding"),c=function(e){var t=l.elem(this,"canvas");u.propInteger(this,"width")(function(e){t.setAttribute("width",e),t.style.width=e+"px"}),u.propInteger(this,"height")(function(e){t.setAttribute("height",e),t.style.height=e+"px"}),e=u.extend({width:640,height:480},e,this);var r=t.getContext("webgl")||t.getContext("experimental-webgl"),n=r.createProgram();r.attachShader(n,i(r,d.vertex)),r.attachShader(n,a(r,d.fragment)),r.linkProgram(n),r.useProgram(n);var o=new Float32Array([-.4,.8,1,0,0,.8,-.8,0,1,0,-.8,-.8,0,0,1]),s=o.BYTES_PER_ELEMENT,c=5*s,g=r.createBuffer();r.bindBuffer(r.ARRAY_BUFFER,g),r.bufferData(r.ARRAY_BUFFER,o,r.STATIC_DRAW);var v=r.getAttribLocation(n,"attI");r.enableVertexAttribArray(v),r.vertexAttribPointer(v,1,r.FLOAT,!1,c,0);var p=r.getAttribLocation(n,"attJ");r.enableVertexAttribArray(p),r.vertexAttribPointer(p,1,r.FLOAT,!1,c,1*s);var h=r.getAttribLocation(n,"attC");r.enableVertexAttribArray(h),r.vertexAttribPointer(h,3,r.FLOAT,!1,c,2*s),r.clearColor(0,0,0,1),r.clear(r.COLOR_BUFFER_BIT|r.DEPTH_BUFFER_BIT),r.drawArrays(r.TRIANGLE_STRIP,0,3)};t.exports=c;var d={vertex:"attribute float attI;\nattribute float attJ;\n// `vec3` est un vecteur à trois dimensions.\n// On peut lire les valeurs de ces dimensions\n// de plusieurs façons :\n//   * attC.r == attC.x\n//   * attC.g == attC.y\n//   * attC.b == attC.z\nattribute vec3 attC;\n\n// Les `varying` sont des variables qu'on peut\n// passer du vertex shader au fragment shader.\n// Leurs valeurs sont interpolées entre les\n// vertex les plus proches.\nvarying vec3 varColor;\n\n\n// La fonction principale d'un shader soit toujours\n// s'appeler `main`, n'avoir aucun argument et\n// ne rien retourner.\nvoid main() {\n  // `gl_Position` est une variable SPECIALE de WebGL.\n  // Il faut obligatoirement la renseigner pour\n  // définir les coordonnées du vertex résultant.\n  gl_Position = vec4( attI, attJ, 0.0, 1.0 );\n  // On transmet la couleur au fragment color.\n  varColor = attC;\n}\n",fragment:"// Préciser la précision par défaut.\n// Une ligne qu'il est conseillé de mettre\n// au début de tous vos fragment shaders\n// pour éviter de devoir préciser la précision\n// à chaque déclaration de variable.\n// Les précisions possibles sont\n// lowp, mediump et highp.\nprecision mediump float;\n\nvarying vec3 varColor;\n\nvoid main() {\n  // `gl_FragColor` est une variable SPECIALE de WebGL.\n  // Elle permet de déterminer la couleur du fragment.\n  // C'est un vecteur à 4 dimensions : rouge, vert, bleu\n  // et alpha (l'opacité). Toutes les valeurs sont entre\n  // 0.0 et 1.0.\n  gl_FragColor = vec4(varColor.rgb, 1.0);\n}\n"};t.exports._=r});
=======
require("wdg.gl0",function(r,e,t){function n(r,e,t){var n=e.createShader(r);return e.shaderSource(n,t),e.compileShader(n),e.getShaderParameter(n,e.COMPILE_STATUS)?n:(console.log(t),console.error("An error occurred compiling the shader: "+e.getShaderInfoLog(n)),null)}function a(r,e){return n(r.FRAGMENT_SHADER,r,e)}function i(r,e){return n(r.VERTEX_SHADER,r,e)}var o=function(){function e(){return n(t,arguments)}var t={en:{}},n=r("$").intl;return e.all=t,e}(),s={vertex:"attribute float attI;\r\nattribute float attJ;\r\n// `vec3` est un vecteur à trois dimensions.\r\n// On peut lire les valeurs de ces dimensions\r\n// de plusieurs façons :\r\n//   * attC.r == attC.x\r\n//   * attC.g == attC.y\r\n//   * attC.b == attC.z\r\nattribute vec3 attC;\r\n\r\n// Les `varying` sont des variables qu'on peut\r\n// passer du vertex shader au fragment shader.\r\n// Leurs valeurs sont interpolées entre les\r\n// vertex les plus proches.\r\nvarying vec3 varColor;\r\n\r\n\r\n// La fonction principale d'un shader soit toujours\r\n// s'appeler `main`, n'avoir aucun argument et\r\n// ne rien retourner.\r\nvoid main() {\r\n  // `gl_Position` est une variable SPECIALE de WebGL.\r\n  // Il faut obligatoirement la renseigner pour\r\n  // définir les coordonnées du vertex résultant.\r\n  gl_Position = vec4( attI, attJ, 0.0, 1.0 );\r\n  // On transmet la couleur au fragment color.\r\n  varColor = attC;\r\n}\r\n",fragment:"// Préciser la précision par défaut.\r\n// Une ligne qu'il est conseillé de mettre\r\n// au début de tous vos fragment shaders\r\n// pour éviter de devoir préciser la précision\r\n// à chaque déclaration de variable.\r\n// Les précisions possibles sont\r\n// lowp, mediump et highp.\r\nprecision mediump float;\r\n\r\nvarying vec3 varColor;\r\n\r\nvoid main() {\r\n  // `gl_FragColor` est une variable SPECIALE de WebGL.\r\n  // Elle permet de déterminer la couleur du fragment.\r\n  // C'est un vecteur à 4 dimensions : rouge, vert, bleu\r\n  // et alpha (l'opacité). Toutes les valeurs sont entre\r\n  // 0.0 et 1.0.\r\n  gl_FragColor = vec4(varColor.rgb, 1.0);\r\n}\r\n"},l=r("dom"),u=r("tfw.data-binding"),c=function(r){var e=l.elem(this,"canvas");u.propInteger(this,"width")(function(r){e.setAttribute("width",r),e.style.width=r+"px"}),u.propInteger(this,"height")(function(r){e.setAttribute("height",r),e.style.height=r+"px"}),r=u.extend({width:640,height:480},r,this);var t=e.getContext("webgl")||e.getContext("experimental-webgl"),n=t.createProgram();t.attachShader(n,i(t,s.vertex)),t.attachShader(n,a(t,s.fragment)),t.linkProgram(n),t.useProgram(n);var o=new Float32Array([-.4,.8,1,0,0,.8,-.8,0,1,0,-.8,-.8,0,0,1]),c=o.BYTES_PER_ELEMENT,d=5*c,g=t.createBuffer();t.bindBuffer(t.ARRAY_BUFFER,g),t.bufferData(t.ARRAY_BUFFER,o,t.STATIC_DRAW);var v=t.getAttribLocation(n,"attI");t.enableVertexAttribArray(v),t.vertexAttribPointer(v,1,t.FLOAT,!1,d,0);var p=t.getAttribLocation(n,"attJ");t.enableVertexAttribArray(p),t.vertexAttribPointer(p,1,t.FLOAT,!1,d,1*c);var h=t.getAttribLocation(n,"attC");t.enableVertexAttribArray(h),t.vertexAttribPointer(h,3,t.FLOAT,!1,d,2*c),t.clearColor(0,0,0,1),t.clear(t.COLOR_BUFFER_BIT|t.DEPTH_BUFFER_BIT),t.drawArrays(t.TRIANGLE_STRIP,0,3)};e.exports=c,e.exports._=o});
>>>>>>> ed60770fef43ceb6207a072673d058559ad5436c
//# sourceMappingURL=wdg.gl0.js.map