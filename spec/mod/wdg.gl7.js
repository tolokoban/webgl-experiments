require("wdg.gl7",function(t,n){function a(){return c(u,arguments)}function e(t,n){function a(t){window.requestAnimationFrame(a),e.clear(e.COLOR_BUFFER_BIT),e.uniform1f(y,t),e.drawArrays(e.POINTS,0,m)}var e=t.getContext("webgl")||t.getContext("experimental-webgl"),r=e.createProgram();e.attachShader(r,i(e,g.vertex)),e.attachShader(r,o(e,g.fragment)),e.linkProgram(r),e.useProgram(r);var u=e.createBuffer();e.bindBuffer(e.ARRAY_BUFFER,u);var c,l,f=0,s=d(n),h=[];for(l=0;l<n.height;l++)for(c=0;c<n.width;c++)s[f]+s[f+1]+s[f+2]<50&&s[f+3]>240&&h.push([2*c/n.width-1,1-2*l/n.height]),f+=4;var m=h.length,v=[];h.forEach(function(t){v.push(t[0]),v.push(t[1]),v.push(Math.random()),v.push(Math.random()),v.push(Math.random()),v.push(Math.random())});var A=new Float32Array(v);e.bufferData(e.ARRAY_BUFFER,A,e.STATIC_DRAW);var p=A.BYTES_PER_ELEMENT,x=6*p,R=e.getAttribLocation(r,"attPosition");e.enableVertexAttribArray(R),e.vertexAttribPointer(R,2,e.FLOAT,!1,x,0);var b=e.getAttribLocation(r,"attRandom");e.enableVertexAttribArray(b),e.vertexAttribPointer(b,4,e.FLOAT,!1,x,2*p),e.disable(e.DEPTH_TEST),e.enable(e.BLEND),e.blendFuncSeparate(e.SRC_ALPHA,e.ONE_MINUS_SRC_ALPHA,e.ZERO,e.ONE),e.blendEquation(e.FUNC_ADD);var y=e.getUniformLocation(r,"uniTime");e.clearColor(1,1,1,1),e.bindBuffer(e.ARRAY_BUFFER,u),window.requestAnimationFrame(a)}function r(t,n,a){var e=n.createShader(t);return n.shaderSource(e,a),n.compileShader(e),n.getShaderParameter(e,n.COMPILE_STATUS)?e:(console.log(a),console.error("An error occurred compiling the shader: "+n.getShaderInfoLog(e)),null)}function o(t,n){return r(t.FRAGMENT_SHADER,t,n)}function i(t,n){return r(t.VERTEX_SHADER,t,n)}function d(t){var n=t.width,a=t.height,e=document.createElement("canvas");e.setAttribute("width",n),e.setAttribute("height",a);var r=e.getContext("2d");return r.drawImage(t,0,0),document.body.appendChild(e),r.getImageData(0,0,n,a).data}var u={en:{}},c=require("$").intl,l=require("dom"),f=require("tfw.data-binding"),s=function(t){var n=l.elem(this,"canvas");f.propInteger(this,"width")(function(t){n.setAttribute("width",t),n.style.width=t+"px"}),f.propInteger(this,"height")(function(t){n.setAttribute("height",t),n.style.height=t+"px"}),f.propBoolean(this,"zindex"),t=f.extend({width:640,height:480,zbuffer:!1},t,this);var a=new Image;a.src="css/wdg.gl7/tp.png",a.onload=e.bind(this,n,a)};n.exports=s;var g={vertex:"uniform float uniTime;\n\nattribute vec2 attPosition;\nattribute vec4 attRandom;\n\nvarying vec3 varColor;\nvarying float varCoeff;\n\nvoid main() {\n  float t = dot(attRandom, attRandom) * 10000.0 + uniTime / 100.0;\n  float x = attPosition.x;\n  float y = attPosition.y;\n\n  float radius = .02 * cos(t * attRandom.y);\n  float ang = uniTime * attRandom.z / 100.0;\n  x = x + radius * cos(ang);\n  y = y + radius * sin(ang);\n\n  radius = 1.5 * sin(t * 0.01 * (attRandom.y + attRandom.x));\n  ang = t * attRandom.x * 0.1;\n  float xx = radius * cos(ang);\n  float yy = radius * sin(ang);\n\n  float c1 = 0.0;\n  float tt = mod(uniTime, 12000.0);\n  if (tt < 4000.0) {\n    c1 = sin(tt * 3.1415926539 / 4000.0);\n  }\n  float c2 = 1.0 - c1;\n\n  varCoeff = c2;\n  varColor = vec3( 0.0, .3 + .1 * abs(cos(attRandom.x * uniTime * 0.01)), 0.0 );\n\n  gl_Position = vec4( x * c2 + xx * c1, y * c2 + yy * c1, 0.0, 1.0 );\n  ang = t * attRandom.x;\n  gl_PointSize = max(8.0, (32.0 + 8.0 * cos(ang)) * c2);\n}\n",fragment:"precision mediump float;\n\nvarying vec3 varColor;\nvarying float varCoeff;\n\nvoid main() {\n  // Calculons la distance du fragment courant\n  // au centre du point.\n  float x = gl_PointCoord.x - 0.5;\n  float y = gl_PointCoord.y - 0.5;\n  // On ne calcule pas la racine carrÃ© pour gagner du temps.\n  float r = x*x + y*y;\n  float alpha = clamp(1.0 - r * 4.0, 0.0, 1.0);\n\n  gl_FragColor = vec4( varColor, alpha * (1.0 - varCoeff * 0.3) );\n}\n"};n.exports._=a});
//# sourceMappingURL=wdg.gl7.js.map