require("explosive-tp",function(t,n){function a(){return o(r,arguments)}function e(t){var n=this._webgl,a=n.gl,e=a.createBuffer();this._buffer=e,a.bindBuffer(a.ARRAY_BUFFER,e);var r,o,i=0,s=n.getDataFromImage(t),l=[];for(o=0;o<t.height;o++)for(r=0;r<t.width;r++)s[i]+s[i+1]+s[i+2]<50&&s[i+3]>240&&l.push([2*r/t.width-1,1-2*o/t.height]),i+=4;var d=l.length,u=[];l.forEach(function(t){u.push(t[0]),u.push(t[1]),u.push(Math.random()),u.push(Math.random()),u.push(Math.random()),u.push(Math.random())});var c=new Float32Array(u);a.bufferData(a.ARRAY_BUFFER,c,a.STATIC_DRAW);var f=c.BYTES_PER_ELEMENT,g=6*f,p=a.getAttribLocation(this._prg.program,"attPosition");a.enableVertexAttribArray(p),a.vertexAttribPointer(p,2,a.FLOAT,!1,g,0);var m=a.getAttribLocation(this._prg.program,"attRandom");a.enableVertexAttribArray(m),a.vertexAttribPointer(m,4,a.FLOAT,!1,g,2*f),a.disable(a.DEPTH_TEST),a.enable(a.BLEND),a.blendFuncSeparate(a.SRC_ALPHA,a.ONE_MINUS_SRC_ALPHA,a.ZERO,a.ONE),a.blendEquation(a.FUNC_ADD),a.clearColor(1,1,1,1),a.bindBuffer(a.ARRAY_BUFFER,e),this._loaded=!0,this._count=d,this._data=c}var r={en:{}},o=require("$").intl,i=require("tfw.webgl"),s=function(t){var n=new i(t),a=n.createProgram({vertex:l.vert,fragment:l.frag});this._webgl=n,this._prg=a,this._loaded=!1;var r=new Image;r.src="css/explosive-tp/tp.png",r.onload=e.bind(this,r)};s.prototype.render=function(t){if(this._loaded){var n=this._webgl.gl,a=this._prg;a.use(),n.disable(n.DEPTH_TEST),n.enable(n.BLEND),n.blendFuncSeparate(n.SRC_ALPHA,n.ONE_MINUS_SRC_ALPHA,n.ZERO,n.ONE),n.blendEquation(n.FUNC_ADD),a.$uniTime=t,n.bindBuffer(n.ARRAY_BUFFER,this._buffer);var e=this._data.BYTES_PER_ELEMENT,r=6*e,o=n.getAttribLocation(this._prg.program,"attPosition");n.enableVertexAttribArray(o),n.vertexAttribPointer(o,2,n.FLOAT,!1,r,0);var i=n.getAttribLocation(this._prg.program,"attRandom");n.enableVertexAttribArray(i),n.vertexAttribPointer(i,4,n.FLOAT,!1,r,2*e),n.bufferData(n.ARRAY_BUFFER,this._data,n.STATIC_DRAW),n.drawArrays(n.POINTS,0,this._count)}},n.exports=s;var l={vert:'// Temps courant en millisecondes\nuniform float uniTime;\n\n// Position en valeurs comprises entre -1.0 et +1.0\nattribute vec2 attPosition;\n// 4 Valeurs aléatoires comprises entre 0.0 et 1.0\n// Ces valeurs donnent la "personnalité" de la particule\nattribute vec4 attRandom;\n\n// Couleur pour le fragment shader\nvarying vec3 varColor;\n// Indique au fragment shader si les particules sont\n// en place (1.0) ou en mouvement désordonné (0.0)\nvarying float varCoeff;\n\nvoid main() {\n  float t = dot(attRandom, attRandom) * 10000.0 + uniTime / 100.0;\n  // Position "en place" de la particule.\n  float x = attPosition.x;\n  float y = attPosition.y;\n\n  // Créer un léger mouvement autour de la position normale.\n  float radius = .02 * cos(t * attRandom.y);\n  float ang = uniTime * attRandom.z / 100.0;\n  x = x + radius * cos(ang);\n  y = y + radius * sin(ang);\n\n  // Coordonnées aléatoires en rotation dans tout l\'espace.\n  radius = 1.5 * sin(t * 0.01 * (attRandom.y + attRandom.x));\n  ang = t * attRandom.x * 0.1;\n  float xx = radius * cos(ang);\n  float yy = radius * sin(ang);\n\n  // Dans un cycle de 12 secondes, l\'image est stable\n  // pendant 8 secondes et en vrac pendant 4.\n  float c1 = 0.0;\n  float tt = mod(uniTime, 12000.0);\n  if (tt < 4000.0) {\n    c1 = sin(tt * 3.1415926539 / 4000.0);\n  }\n  float c2 = 1.0 - c1;\n\n  varCoeff = c2;\n  // Petites variations de vert.\n  varColor = vec3( 0.0, .3 + .1 * abs(cos(attRandom.x * uniTime * 0.01)), 0.0 );\n  // La position est intrerpolée entre (x,y) et (xx,yy).\n  gl_Position = vec4( x * c2 + xx * c1, y * c2 + yy * c1, 0.0, 1.0 );\n  // Palpitation de la taille et diminution lors de la phase de désordre.\n  ang = t * attRandom.x;\n  gl_PointSize = max(8.0, (32.0 + 8.0 * cos(ang)) * (.5 + c2 * .5));\n}\n',frag:"precision mediump float;\n\nvarying vec3 varColor;\nvarying float varCoeff;\n\nvoid main() {\n  // Calculons la distance du fragment courant\n  // au centre du point.\n  float x = gl_PointCoord.x - 0.5;\n  float y = gl_PointCoord.y - 0.5;\n  // On ne calcule pas la racine carré pour gagner du temps.\n  float r = x*x + y*y;\n  float alpha = clamp(1.0 - r * 4.0, 0.0, 1.0);\n\n  gl_FragColor = vec4( varColor, alpha * (1.0 - varCoeff * 0.3) );\n}\n"};n.exports._=a});
//# sourceMappingURL=explosive-tp.js.map