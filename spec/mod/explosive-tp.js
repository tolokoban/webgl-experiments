require("explosive-tp",function(r,n){function t(){return o(e,arguments)}function a(r){var n=this._webgl,t=n.gl,a=t.createBuffer();t.bindBuffer(t.ARRAY_BUFFER,a);var e,o,i=0,s=n.getDataFromImage(r),l=[];for(o=0;o<r.height;o++)for(e=0;e<r.width;e++)s[i]+s[i+1]+s[i+2]<50&&s[i+3]>240&&l.push([2*e/r.width-1,1-2*o/r.height]),i+=4;var d=l.length,u=[];l.forEach(function(r){u.push(r[0]),u.push(r[1]),u.push(Math.random()),u.push(Math.random()),u.push(Math.random()),u.push(Math.random())});var c=new Float32Array(u);t.bufferData(t.ARRAY_BUFFER,c,t.STATIC_DRAW);var f=c.BYTES_PER_ELEMENT,m=6*f,p=t.getAttribLocation(this._prg.program,"attPosition");t.enableVertexAttribArray(p),t.vertexAttribPointer(p,2,t.FLOAT,!1,m,0);var g=t.getAttribLocation(this._prg.program,"attRandom");t.enableVertexAttribArray(g),t.vertexAttribPointer(g,4,t.FLOAT,!1,m,2*f),t.disable(t.DEPTH_TEST),t.enable(t.BLEND),t.blendFuncSeparate(t.SRC_ALPHA,t.ONE_MINUS_SRC_ALPHA,t.ZERO,t.ONE),t.blendEquation(t.FUNC_ADD),t.clearColor(1,1,1,1),t.bindBuffer(t.ARRAY_BUFFER,a),this._loaded=!0,this._count=d}var e={en:{}},o=require("$").intl,i=require("tfw.webgl"),s=function(r){var n=new i(r),t=n.createProgram({vertex:l.vert,fragment:l.frag});this._webgl=n,this._prg=t,this._loaded=!1;var e=new Image;e.src="css/explosive-tp/tp.png",e.onload=a.bind(this,e)};s.prototype.render=function(r){if(this._loaded){var n=this._webgl.gl,t=this._prg;t.use(),t.$uniTime=r,n.drawArrays(n.POINTS,0,this._count)}},n.exports=s;var l={vert:'// Temps courant en millisecondes\r\nuniform float uniTime;\r\n\r\n// Position en valeurs comprises entre -1.0 et +1.0\r\nattribute vec2 attPosition;\r\n// 4 Valeurs aléatoires comprises entre 0.0 et 1.0\r\n// Ces valeurs donnent la "personnalité" de la particule\r\nattribute vec4 attRandom;\r\n\r\n// Couleur pour le fragment shader\r\nvarying vec3 varColor;\r\n// Indique au fragment shader si les particules sont\r\n// en place (1.0) ou en mouvement désordonné (0.0)\r\nvarying float varCoeff;\r\n\r\nvoid main() {\r\n  float t = dot(attRandom, attRandom) * 10000.0 + uniTime / 100.0;\r\n  // Position "en place" de la particule.\r\n  float x = attPosition.x;\r\n  float y = attPosition.y;\r\n\r\n  // Créer un léger mouvement autour de la position normale.\r\n  float radius = .02 * cos(t * attRandom.y);\r\n  float ang = uniTime * attRandom.z / 100.0;\r\n  x = x + radius * cos(ang);\r\n  y = y + radius * sin(ang);\r\n\r\n  // Coordonnées aléatoires en rotation dans tout l\'espace.\r\n  radius = 1.5 * sin(t * 0.01 * (attRandom.y + attRandom.x));\r\n  ang = t * attRandom.x * 0.1;\r\n  float xx = radius * cos(ang);\r\n  float yy = radius * sin(ang);\r\n\r\n  // Dans un cycle de 12 secondes, l\'image est stable\r\n  // pendant 8 secondes et en vrac pendant 4.\r\n  float c1 = 0.0;\r\n  float tt = mod(uniTime, 12000.0);\r\n  if (tt < 4000.0) {\r\n    c1 = sin(tt * 3.1415926539 / 4000.0);\r\n  }\r\n  float c2 = 1.0 - c1;\r\n\r\n  varCoeff = c2;\r\n  // Petites variations de vert.\r\n  varColor = vec3( 0.0, .3 + .1 * abs(cos(attRandom.x * uniTime * 0.01)), 0.0 );\r\n  // La position est intrerpolée entre (x,y) et (xx,yy).\r\n  gl_Position = vec4( x * c2 + xx * c1, y * c2 + yy * c1, 0.0, 1.0 );\r\n  // Palpitation de la taille et diminution lors de la phase de désordre.\r\n  ang = t * attRandom.x;\r\n  gl_PointSize = max(8.0, (32.0 + 8.0 * cos(ang)) * (.5 + c2 * .5));\r\n}\r\n',frag:"precision mediump float;\r\n\r\nvarying vec3 varColor;\r\nvarying float varCoeff;\r\n\r\nvoid main() {\r\n  // Calculons la distance du fragment courant\r\n  // au centre du point.\r\n  float x = gl_PointCoord.x - 0.5;\r\n  float y = gl_PointCoord.y - 0.5;\r\n  // On ne calcule pas la racine carré pour gagner du temps.\r\n  float r = x*x + y*y;\r\n  float alpha = clamp(1.0 - r * 4.0, 0.0, 1.0);\r\n\r\n  gl_FragColor = vec4( varColor, alpha * (1.0 - varCoeff * 0.3) );\r\n}\r\n"};n.exports._=t});
//# sourceMappingURL=explosive-tp.js.map