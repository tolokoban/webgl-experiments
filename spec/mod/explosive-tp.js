require("explosive-tp",function(r,t,n){function a(r){var t=this._webgl,n=t.gl,a=n.createBuffer();this._buffer=a,n.bindBuffer(n.ARRAY_BUFFER,a);var e,o,i=0,s=t.getDataFromImage(r),l=[];for(o=0;o<r.height;o++)for(e=0;e<r.width;e++)s[i]+s[i+1]+s[i+2]<50&&s[i+3]>240&&l.push([2*e/r.width-1,1-2*o/r.height]),i+=4;var d=l.length,u=[];l.forEach(function(r){u.push(r[0]),u.push(r[1]),u.push(Math.random()),u.push(Math.random()),u.push(Math.random()),u.push(Math.random())});var c=new Float32Array(u);n.bufferData(n.ARRAY_BUFFER,c,n.STATIC_DRAW);var f=c.BYTES_PER_ELEMENT,g=6*f,p=n.getAttribLocation(this._prg.program,"attPosition");n.enableVertexAttribArray(p),n.vertexAttribPointer(p,2,n.FLOAT,!1,g,0);var m=n.getAttribLocation(this._prg.program,"attRandom");n.enableVertexAttribArray(m),n.vertexAttribPointer(m,4,n.FLOAT,!1,g,2*f),n.disable(n.DEPTH_TEST),n.enable(n.BLEND),n.blendFuncSeparate(n.SRC_ALPHA,n.ONE_MINUS_SRC_ALPHA,n.ZERO,n.ONE),n.blendEquation(n.FUNC_ADD),n.clearColor(1,1,1,1),n.bindBuffer(n.ARRAY_BUFFER,a),this._loaded=!0,this._count=d,this._data=c}var e=function(){function t(){return a(n,arguments)}var n={en:{}},a=r("$").intl;return t.all=n,t}(),o={vert:'// Temps courant en millisecondes\r\nuniform float uniTime;\r\n\r\n// Position en valeurs comprises entre -1.0 et +1.0\r\nattribute vec2 attPosition;\r\n// 4 Valeurs aléatoires comprises entre 0.0 et 1.0\r\n// Ces valeurs donnent la "personnalité" de la particule\r\nattribute vec4 attRandom;\r\n\r\n// Couleur pour le fragment shader\r\nvarying vec3 varColor;\r\n// Indique au fragment shader si les particules sont\r\n// en place (1.0) ou en mouvement désordonné (0.0)\r\nvarying float varCoeff;\r\n\r\nvoid main() {\r\n  float t = dot(attRandom, attRandom) * 10000.0 + uniTime / 100.0;\r\n  // Position "en place" de la particule.\r\n  float x = attPosition.x;\r\n  float y = attPosition.y;\r\n\r\n  // Créer un léger mouvement autour de la position normale.\r\n  float radius = .02 * cos(t * attRandom.y);\r\n  float ang = uniTime * attRandom.z / 100.0;\r\n  x = x + radius * cos(ang);\r\n  y = y + radius * sin(ang);\r\n\r\n  // Coordonnées aléatoires en rotation dans tout l\'espace.\r\n  radius = 1.5 * sin(t * 0.01 * (attRandom.y + attRandom.x));\r\n  ang = t * attRandom.x * 0.1;\r\n  float xx = radius * cos(ang);\r\n  float yy = radius * sin(ang);\r\n\r\n  // Dans un cycle de 12 secondes, l\'image est stable\r\n  // pendant 8 secondes et en vrac pendant 4.\r\n  float c1 = 0.0;\r\n  float tt = mod(uniTime, 12000.0);\r\n  if (tt < 4000.0) {\r\n    c1 = sin(tt * 3.1415926539 / 4000.0);\r\n  }\r\n  float c2 = 1.0 - c1;\r\n\r\n  varCoeff = c2;\r\n  // Petites variations de vert.\r\n  varColor = vec3( 0.0, .3 + .1 * abs(cos(attRandom.x * uniTime * 0.01)), 0.0 );\r\n  // La position est intrerpolée entre (x,y) et (xx,yy).\r\n  gl_Position = vec4( x * c2 + xx * c1, y * c2 + yy * c1, 0.0, 1.0 );\r\n  // Palpitation de la taille et diminution lors de la phase de désordre.\r\n  ang = t * attRandom.x;\r\n  gl_PointSize = max(8.0, (32.0 + 8.0 * cos(ang)) * (.5 + c2 * .5));\r\n}\r\n',frag:"precision mediump float;\r\n\r\nvarying vec3 varColor;\r\nvarying float varCoeff;\r\n\r\nvoid main() {\r\n  // Calculons la distance du fragment courant\r\n  // au centre du point.\r\n  float x = gl_PointCoord.x - 0.5;\r\n  float y = gl_PointCoord.y - 0.5;\r\n  // On ne calcule pas la racine carré pour gagner du temps.\r\n  float r = x*x + y*y;\r\n  float alpha = clamp(1.0 - r * 4.0, 0.0, 1.0);\r\n\r\n  gl_FragColor = vec4( varColor, alpha * (1.0 - varCoeff * 0.3) );\r\n}\r\n"},i=r("tfw.webgl"),s=function(r){var t=new i(r),n=t.createProgram({vertex:o.vert,fragment:o.frag});this._webgl=t,this._prg=n,this._loaded=!1;var e=new Image;e.src="css/explosive-tp/tp.png",e.onload=a.bind(this,e)};s.prototype.render=function(r){if(this._loaded){var t=this._webgl.gl,n=this._prg;n.use(),t.disable(t.DEPTH_TEST),t.enable(t.BLEND),t.blendFuncSeparate(t.SRC_ALPHA,t.ONE_MINUS_SRC_ALPHA,t.ZERO,t.ONE),t.blendEquation(t.FUNC_ADD),n.$uniTime=r,t.bindBuffer(t.ARRAY_BUFFER,this._buffer);var a=this._data.BYTES_PER_ELEMENT,e=6*a,o=t.getAttribLocation(this._prg.program,"attPosition");t.enableVertexAttribArray(o),t.vertexAttribPointer(o,2,t.FLOAT,!1,e,0);var i=t.getAttribLocation(this._prg.program,"attRandom");t.enableVertexAttribArray(i),t.vertexAttribPointer(i,4,t.FLOAT,!1,e,2*a),t.bufferData(t.ARRAY_BUFFER,this._data,t.STATIC_DRAW),t.drawArrays(t.POINTS,0,this._count)}},t.exports=s,t.exports._=e});
//# sourceMappingURL=explosive-tp.js.map