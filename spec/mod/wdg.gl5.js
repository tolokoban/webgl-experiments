require("wdg.gl5",function(t,e,n){function r(t){function e(n){a.bindTexture(a.TEXTURE_2D,P),a.uniform1f(b,t.width),a.uniform1f(_,t.height),a.activeTexture(a.TEXTURE0),a.bindTexture(a.TEXTURE_2D,P),a.uniform1i(a.getUniformLocation(i,"uniTexture"),0);var r=0;x.forEach(function(t,e){var o=t.x*l,a=d-Math.abs(Math.cos(t.y*Math.PI+n*t.scale/3613))*d,i=Math.cos(n*t.scale/2700),s=128*(1-.4*i),c=n*t.rotation/700;[0,1,3,2].forEach(function(t){T[r++]=o,T[r++]=a,T[r++]=i,T[r++]=t,T[r++]=s,T[r++]=c})}),a.bindBuffer(a.ARRAY_BUFFER,h),a.bufferData(a.ARRAY_BUFFER,T,a.STATIC_DRAW),a.clearColor(.3,.8,1,1),a.clear(a.COLOR_BUFFER_BIT|a.DEPTH_BUFFER_BIT);for(var o=0;o<f;o++)a.drawArrays(a.TRIANGLE_STRIP,4*o,4);window.requestAnimationFrame(e)}var n=u.vertex,r=u["fragment-"+this.fragment],a=t.getContext("webgl"),i=a.createProgram();a.attachShader(i,c(a,n)),a.attachShader(i,s(a,r)),a.linkProgram(i),a.useProgram(i);var l=t.width,d=t.height,f=150,x=o(f),h=a.createBuffer(),T=new Float32Array(6*f*4),v=T.BYTES_PER_ELEMENT,E=6*v;a.bindBuffer(a.ARRAY_BUFFER,h);var g=a.getAttribLocation(i,"attPosition");a.enableVertexAttribArray(g),a.vertexAttribPointer(g,3,a.FLOAT,!1,E,0);var A=a.getAttribLocation(i,"attIndex");a.enableVertexAttribArray(A),a.vertexAttribPointer(A,1,a.FLOAT,!1,E,3*v);var m=a.getAttribLocation(i,"attScale");a.enableVertexAttribArray(m),a.vertexAttribPointer(m,1,a.FLOAT,!1,E,4*v);var R=a.getAttribLocation(i,"attRotation");a.enableVertexAttribArray(R),a.vertexAttribPointer(R,1,a.FLOAT,!1,E,5*v);var p=a.getAttribLocation(i,"attVertexPosition");a.enableVertexAttribArray(p),a.vertexAttribPointer(p,3,a.FLOAT,!1,0,0);var b=a.getUniformLocation(i,"uniWidth"),_=a.getUniformLocation(i,"uniHeight");a.disable(a.DEPTH_TEST);var P=a.createTexture();a.bindTexture(a.TEXTURE_2D,P),a.texParameteri(a.TEXTURE_2D,a.TEXTURE_WRAP_S,a.CLAMP_TO_EDGE),a.texParameteri(a.TEXTURE_2D,a.TEXTURE_WRAP_T,a.CLAMP_TO_EDGE),a.texParameteri(a.TEXTURE_2D,a.TEXTURE_MIN_FILTER,a.NEAREST),a.texParameteri(a.TEXTURE_2D,a.TEXTURE_MAG_FILTER,a.NEAREST);var L=new Image;L.onload=function(){a.texImage2D(a.TEXTURE_2D,0,a.RGBA,a.RGBA,a.UNSIGNED_BYTE,L),window.requestAnimationFrame(e)},L.onerror=function(t){throw t},L.src="css/wdg.gl5/champi.png",a.enable(a.BLEND),a.blendFunc(a.SRC_ALPHA,a.ONE_MINUS_SRC_ALPHA),a.disable(a.DEPTH_TEST)}function o(t){for(var e=[];t-- >0;)e.push({x:a(0,1),y:a(0,1),z:a(.1,.9),size:a(20,100),scale:a(.7,3.2),rotation:a(-2,2)});return e}function a(t,e){return t+Math.random()*(e-t)}function i(t,e,n){var r=e.createShader(t);return e.shaderSource(r,n),e.compileShader(r),e.getShaderParameter(r,e.COMPILE_STATUS)?r:(console.log(n),console.error("An error occurred compiling the shader: "+e.getShaderInfoLog(r)),null)}function s(t,e){return i(t.FRAGMENT_SHADER,t,e)}function c(t,e){return i(t.VERTEX_SHADER,t,e)}var l=function(){function e(){return r(n,arguments)}var n={en:{}},r=t("$").intl;return e.all=n,e}(),u={vertex:"// Coordonnées du centre du sprite.\nattribute vec3 attPosition;\n// Index du vertex (de 0.0 à 3.0).\nattribute float attIndex;\n// Angle de rotation en radians.\nattribute float attRotation;\n// Facteur d'échelle.\nattribute float attScale;\n// PI est une constante indispensable en trigonométrie.\nconst float PI = 3.1415926536;\n// La taille du canvas est utilisée pour convertir\n// des coordonnées en pixels vers l'espace de WebGL.\nuniform float uniWidth;\nuniform float uniHeight;\n// Passer au fragment shader les coordonnées UV\n// du vertex dans le bitmap.\nvarying vec2 varCoordsUV;\n\nvoid main() {\n  // On considère un cercle ce centre attPosition,\n  // et de rayon attScale.\n  // Les vertex sont sur ce cercle, c'est pourquoi\n  // on utilise attIndex comme un angle.\n  float x = attPosition.x \n    + attScale * cos( attRotation + attIndex * PI / 2.0 );\n  float y = attPosition.y\n    + attScale * sin( attRotation + attIndex * PI / 2.0 );\n  // On avait des coordonnées en pixels du canvas,\n  // il faut les convertir dans l'espace de WebGL.\n  x = (2.0 * x / uniWidth) - 1.0;\n  y = 1.0 - (2.0 * y / uniHeight);\n  // D�finir la position du vertex.\n  gl_Position = vec4( x, y, attPosition.z, 1.0 );\n  // Il faut associer à chaque attIndex, des coordonnées UV.\n  if (attIndex < 1.5) {\n    if (attIndex < 0.5) varCoordsUV = vec2(0.0, 0.0); // 0\n    else varCoordsUV = vec2(1.0, 0.0);                // 1\n  }\n  else {\n    if (attIndex < 2.5) varCoordsUV = vec2(1.0, 1.0); // 2\n    else varCoordsUV = vec2(0.0, 1.0);                // 3\n  }\n}\n","fragment-a":"precision mediump float;\n// L'image de notre sprite.\nuniform sampler2D uniTexture;\n// Les coordonnes UV du pixel à dessiner.\n// (0,0) correspond au pixel en haut à gauche.\n// (1,1) correspond au pixel en bas à droite.\nvarying vec2 varCoordsUV;\n\nvoid main() {\n  // texture2D retourne la coleur à un endroit donné.\n  vec4 color = texture2D( uniTexture, varCoordsUV );\n  // Si le point est transparent, on ne l'affiche pas.\n  if ( color.a < 0.1 ) discard;\n  gl_FragColor = color;\n}\n","fragment-b":"const highp float PI = 3.1415926539;\nconst lowp vec3 COLOR0 = vec3(0.7, 0.9, 1.0);\nconst lowp vec3 COLOR1 = vec3(0.0, 0.7, 0.9);\n\nvarying lowp vec3 varVertexPosition;\n\nuniform lowp float uniTimeF;\n\nvoid main() {\n  highp float time = uniTimeF / 700.0;\n  \n  lowp float x = varVertexPosition.x + time * 120.0;\n  lowp float y = varVertexPosition.y + sin(time) * 15.0;\n  \n  lowp float xx = x / 10.0;\n  lowp float yy = y / 10.0;\n  \n  lowp float h = cos(yy) * cos(xx) + sin(yy);\n  h = cos( PI * h + time);\n  \n  h = (1.0 + h) / 2.0;\n  gl_FragColor = vec4( h * COLOR0 + (1.0 - h) * COLOR1, 1.0);\n}\n"},d=t("dom"),f=t("tfw.data-binding"),x=function(t){var e=d.elem(this,"canvas");f.propInteger(this,"width")(function(t){e.setAttribute("width",t),e.style.width=t+"px"}),f.propInteger(this,"height")(function(t){e.setAttribute("height",t),e.style.height=t+"px"}),f.propString(this,"fragment"),t=f.extend({width:640,height:480,fragment:"a"},t,this),window.setTimeout(r.bind(this,e),20)};e.exports=x,e.exports._=l});
//# sourceMappingURL=wdg.gl5.js.map