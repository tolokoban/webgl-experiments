require("wdg.gl5",function(r,t,e){function n(r){function t(e){a.bindTexture(a.TEXTURE_2D,P),a.uniform1f(b,r.width),a.uniform1f(_,r.height),a.activeTexture(a.TEXTURE0),a.bindTexture(a.TEXTURE_2D,P),a.uniform1i(a.getUniformLocation(i,"uniTexture"),0);var n=0;x.forEach(function(r,t){var o=r.x*l,a=d-Math.abs(Math.cos(r.y*Math.PI+e*r.scale/3613))*d,i=Math.cos(e*r.scale/2700),s=128*(1-.4*i),c=e*r.rotation/700;[0,1,3,2].forEach(function(r){T[n++]=o,T[n++]=a,T[n++]=i,T[n++]=r,T[n++]=s,T[n++]=c})}),a.bindBuffer(a.ARRAY_BUFFER,h),a.bufferData(a.ARRAY_BUFFER,T,a.STATIC_DRAW),a.clearColor(.3,.8,1,1),a.clear(a.COLOR_BUFFER_BIT|a.DEPTH_BUFFER_BIT);for(var o=0;o<f;o++)a.drawArrays(a.TRIANGLE_STRIP,4*o,4);window.requestAnimationFrame(t)}var e=u.vertex,n=u["fragment-"+this.fragment],a=r.getContext("webgl"),i=a.createProgram();a.attachShader(i,c(a,e)),a.attachShader(i,s(a,n)),a.linkProgram(i),a.useProgram(i);var l=r.width,d=r.height,f=150,x=o(f),h=a.createBuffer(),T=new Float32Array(6*f*4),v=T.BYTES_PER_ELEMENT,E=6*v;a.bindBuffer(a.ARRAY_BUFFER,h);var g=a.getAttribLocation(i,"attPosition");a.enableVertexAttribArray(g),a.vertexAttribPointer(g,3,a.FLOAT,!1,E,0);var A=a.getAttribLocation(i,"attIndex");a.enableVertexAttribArray(A),a.vertexAttribPointer(A,1,a.FLOAT,!1,E,3*v);var m=a.getAttribLocation(i,"attScale");a.enableVertexAttribArray(m),a.vertexAttribPointer(m,1,a.FLOAT,!1,E,4*v);var R=a.getAttribLocation(i,"attRotation");a.enableVertexAttribArray(R),a.vertexAttribPointer(R,1,a.FLOAT,!1,E,5*v);var p=a.getAttribLocation(i,"attVertexPosition");a.enableVertexAttribArray(p),a.vertexAttribPointer(p,3,a.FLOAT,!1,0,0);var b=a.getUniformLocation(i,"uniWidth"),_=a.getUniformLocation(i,"uniHeight");a.disable(a.DEPTH_TEST);var P=a.createTexture();a.bindTexture(a.TEXTURE_2D,P),a.texParameteri(a.TEXTURE_2D,a.TEXTURE_WRAP_S,a.CLAMP_TO_EDGE),a.texParameteri(a.TEXTURE_2D,a.TEXTURE_WRAP_T,a.CLAMP_TO_EDGE),a.texParameteri(a.TEXTURE_2D,a.TEXTURE_MIN_FILTER,a.NEAREST),a.texParameteri(a.TEXTURE_2D,a.TEXTURE_MAG_FILTER,a.NEAREST);var L=new Image;L.onload=function(){a.texImage2D(a.TEXTURE_2D,0,a.RGBA,a.RGBA,a.UNSIGNED_BYTE,L),window.requestAnimationFrame(t)},L.onerror=function(r){throw r},L.src="css/wdg.gl5/champi.png",a.enable(a.BLEND),a.blendFunc(a.SRC_ALPHA,a.ONE_MINUS_SRC_ALPHA),a.disable(a.DEPTH_TEST)}function o(r){for(var t=[];r-- >0;)t.push({x:a(0,1),y:a(0,1),z:a(.1,.9),size:a(20,100),scale:a(.7,3.2),rotation:a(-2,2)});return t}function a(r,t){return r+Math.random()*(t-r)}function i(r,t,e){var n=t.createShader(r);return t.shaderSource(n,e),t.compileShader(n),t.getShaderParameter(n,t.COMPILE_STATUS)?n:(console.log(e),console.error("An error occurred compiling the shader: "+t.getShaderInfoLog(n)),null)}function s(r,t){return i(r.FRAGMENT_SHADER,r,t)}function c(r,t){return i(r.VERTEX_SHADER,r,t)}var l=function(){function t(){return n(e,arguments)}var e={en:{}},n=r("$").intl;return t.all=e,t}(),u={vertex:"// Coordonnées du centre du sprite.\r\nattribute vec3 attPosition;\r\n// Index du vertex (de 0.0 à 3.0).\r\nattribute float attIndex;\r\n// Angle de rotation en radians.\r\nattribute float attRotation;\r\n// Facteur d'échelle.\r\nattribute float attScale;\r\n// PI est une constante indispensable en trigonométrie.\r\nconst float PI = 3.1415926536;\r\n// La taille du canvas est utilisée pour convertir\r\n// des coordonnées en pixels vers l'espace de WebGL.\r\nuniform float uniWidth;\r\nuniform float uniHeight;\r\n// Passer au fragment shader les coordonnées UV\r\n// du vertex dans le bitmap.\r\nvarying vec2 varCoordsUV;\r\n\r\nvoid main() {\r\n  // On considère un cercle ce centre attPosition,\r\n  // et de rayon attScale.\r\n  // Les vertex sont sur ce cercle, c'est pourquoi\r\n  // on utilise attIndex comme un angle.\r\n  float x = attPosition.x \r\n    + attScale * cos( attRotation + attIndex * PI / 2.0 );\r\n  float y = attPosition.y\r\n    + attScale * sin( attRotation + attIndex * PI / 2.0 );\r\n  // On avait des coordonnées en pixels du canvas,\r\n  // il faut les convertir dans l'espace de WebGL.\r\n  x = (2.0 * x / uniWidth) - 1.0;\r\n  y = 1.0 - (2.0 * y / uniHeight);\r\n  // D�finir la position du vertex.\r\n  gl_Position = vec4( x, y, attPosition.z, 1.0 );\r\n  // Il faut associer à chaque attIndex, des coordonnées UV.\r\n  if (attIndex < 1.5) {\r\n    if (attIndex < 0.5) varCoordsUV = vec2(0.0, 0.0); // 0\r\n    else varCoordsUV = vec2(1.0, 0.0);                // 1\r\n  }\r\n  else {\r\n    if (attIndex < 2.5) varCoordsUV = vec2(1.0, 1.0); // 2\r\n    else varCoordsUV = vec2(0.0, 1.0);                // 3\r\n  }\r\n}\r\n","fragment-a":"precision mediump float;\r\n// L'image de notre sprite.\r\nuniform sampler2D uniTexture;\r\n// Les coordonnes UV du pixel à dessiner.\r\n// (0,0) correspond au pixel en haut à gauche.\r\n// (1,1) correspond au pixel en bas à droite.\r\nvarying vec2 varCoordsUV;\r\n\r\nvoid main() {\r\n  // texture2D retourne la coleur à un endroit donné.\r\n  vec4 color = texture2D( uniTexture, varCoordsUV );\r\n  // Si le point est transparent, on ne l'affiche pas.\r\n  if ( color.a < 0.1 ) discard;\r\n  gl_FragColor = color;\r\n}\r\n","fragment-b":"const highp float PI = 3.1415926539;\r\nconst lowp vec3 COLOR0 = vec3(0.7, 0.9, 1.0);\r\nconst lowp vec3 COLOR1 = vec3(0.0, 0.7, 0.9);\r\n\r\nvarying lowp vec3 varVertexPosition;\r\n\r\nuniform lowp float uniTimeF;\r\n\r\nvoid main() {\r\n  highp float time = uniTimeF / 700.0;\r\n  \r\n  lowp float x = varVertexPosition.x + time * 120.0;\r\n  lowp float y = varVertexPosition.y + sin(time) * 15.0;\r\n  \r\n  lowp float xx = x / 10.0;\r\n  lowp float yy = y / 10.0;\r\n  \r\n  lowp float h = cos(yy) * cos(xx) + sin(yy);\r\n  h = cos( PI * h + time);\r\n  \r\n  h = (1.0 + h) / 2.0;\r\n  gl_FragColor = vec4( h * COLOR0 + (1.0 - h) * COLOR1, 1.0);\r\n}\r\n"},d=r("dom"),f=r("tfw.data-binding"),x=function(r){var t=d.elem(this,"canvas");f.propInteger(this,"width")(function(r){t.setAttribute("width",r),t.style.width=r+"px"}),f.propInteger(this,"height")(function(r){t.setAttribute("height",r),t.style.height=r+"px"}),f.propString(this,"fragment"),r=f.extend({width:640,height:480,fragment:"a"},r,this),window.setTimeout(n.bind(this,t),20)};t.exports=x,t.exports._=l});
//# sourceMappingURL=wdg.gl5.js.map