require("wdg.gl5",function(e,t,n){function r(e){function t(n){o.bindTexture(o.TEXTURE_2D,_),o.uniform1f(b,e.width),o.uniform1f(P,e.height),o.activeTexture(o.TEXTURE0),o.bindTexture(o.TEXTURE_2D,_),o.uniform1i(o.getUniformLocation(i,"uniTexture"),0);var r=0;h.forEach(function(e,t){var a=e.x*l,o=d-Math.abs(Math.cos(e.y*Math.PI+n*e.scale/3613))*d,i=Math.cos(n*e.scale/2700),s=128*(1-.4*i),c=n*e.rotation/700;[0,1,3,2].forEach(function(e){v[r++]=a,v[r++]=o,v[r++]=i,v[r++]=e,v[r++]=s,v[r++]=c})}),o.bindBuffer(o.ARRAY_BUFFER,x),o.bufferData(o.ARRAY_BUFFER,v,o.STATIC_DRAW),o.clearColor(.3,.8,1,1),o.clear(o.COLOR_BUFFER_BIT|o.DEPTH_BUFFER_BIT);for(var a=0;a<f;a++)o.drawArrays(o.TRIANGLE_STRIP,4*a,4);window.requestAnimationFrame(t)}var n=u.vertex,r=u["fragment-"+this.fragment],o=e.getContext("webgl",{alpha:!1,depth:!1,stencil:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,failIfMajorPerformanceCaveat:!0}),i=o.createProgram();o.attachShader(i,c(o,n)),o.attachShader(i,s(o,r)),o.linkProgram(i),o.useProgram(i);var l=e.width,d=e.height,f=150,h=a(f),x=o.createBuffer(),v=new Float32Array(6*f*4),T=v.BYTES_PER_ELEMENT,E=6*T;o.bindBuffer(o.ARRAY_BUFFER,x);var g=o.getAttribLocation(i,"attPosition");o.enableVertexAttribArray(g),o.vertexAttribPointer(g,3,o.FLOAT,!1,E,0);var A=o.getAttribLocation(i,"attIndex");o.enableVertexAttribArray(A),o.vertexAttribPointer(A,1,o.FLOAT,!1,E,3*T);var m=o.getAttribLocation(i,"attScale");o.enableVertexAttribArray(m),o.vertexAttribPointer(m,1,o.FLOAT,!1,E,4*T);var p=o.getAttribLocation(i,"attRotation");o.enableVertexAttribArray(p),o.vertexAttribPointer(p,1,o.FLOAT,!1,E,5*T);var R=o.getAttribLocation(i,"attVertexPosition");o.enableVertexAttribArray(R),o.vertexAttribPointer(R,3,o.FLOAT,!1,0,0);var b=o.getUniformLocation(i,"uniWidth"),P=o.getUniformLocation(i,"uniHeight");o.disable(o.DEPTH_TEST);var _=o.createTexture();o.bindTexture(o.TEXTURE_2D,_),o.texParameteri(o.TEXTURE_2D,o.TEXTURE_WRAP_S,o.CLAMP_TO_EDGE),o.texParameteri(o.TEXTURE_2D,o.TEXTURE_WRAP_T,o.CLAMP_TO_EDGE),o.texParameteri(o.TEXTURE_2D,o.TEXTURE_MIN_FILTER,o.NEAREST),o.texParameteri(o.TEXTURE_2D,o.TEXTURE_MAG_FILTER,o.NEAREST);var I=new Image;I.onload=function(){o.texImage2D(o.TEXTURE_2D,0,o.RGBA,o.RGBA,o.UNSIGNED_BYTE,I),window.requestAnimationFrame(t)},I.onerror=function(e){throw e},I.src="css/gfx/champi.png",o.enable(o.BLEND),o.blendFunc(o.SRC_ALPHA,o.ONE_MINUS_SRC_ALPHA),o.disable(o.DEPTH_TEST)}function a(e){for(var t=[];e-- >0;)t.push({x:o(0,1),y:o(0,1),z:o(.1,.9),size:o(20,100),scale:o(.7,3.2),rotation:o(-2,2)});return t}function o(e,t){return e+Math.random()*(t-e)}function i(e,t,n){var r=t.createShader(e);return t.shaderSource(r,n),t.compileShader(r),t.getShaderParameter(r,t.COMPILE_STATUS)?r:(console.log(n),console.error("An error occurred compiling the shader: "+t.getShaderInfoLog(r)),null)}function s(e,t){return i(e.FRAGMENT_SHADER,e,t)}function c(e,t){return i(e.VERTEX_SHADER,e,t)}var l=function(){function t(){return r(n,arguments)}var n={en:{}},r=e("$").intl;return t.all=n,t}(),u={vertex:"// Coordonnées du centre du sprite.\nattribute vec3 attPosition;\n// Index du vertex (de 0.0 à 3.0).\nattribute float attIndex;\n// Angle de rotation en radians.\nattribute float attRotation;\n// Facteur d'échelle.\nattribute float attScale;\n// PI est une constante indispensable en trigonométrie.\nconst float PI = 3.1415926536;\n// La taille du canvas est utilisée pour convertir\n// des coordonnées en pixels vers l'espace de WebGL.\nuniform float uniWidth;\nuniform float uniHeight;\n// Passer au fragment shader les coordonnées UV\n// du vertex dans le bitmap.\nvarying vec2 varCoordsUV;\n\nvoid main() {\n  // On considère un cercle ce centre attPosition,\n  // et de rayon attScale.\n  // Les vertex sont sur ce cercle, c'est pourquoi\n  // on utilise attIndex comme un angle.\n  float x = attPosition.x \n    + attScale * cos( attRotation + attIndex * PI / 2.0 );\n  float y = attPosition.y\n    + attScale * sin( attRotation + attIndex * PI / 2.0 );\n  // On avait des coordonnées en pixels du canvas,\n  // il faut les convertir dans l'espace de WebGL.\n  x = (2.0 * x / uniWidth) - 1.0;\n  y = 1.0 - (2.0 * y / uniHeight);\n  // D�finir la position du vertex.\n  gl_Position = vec4( x, y, attPosition.z, 1.0 );\n  // Il faut associer à chaque attIndex, des coordonnées UV.\n  if (attIndex < 1.5) {\n    if (attIndex < 0.5) varCoordsUV = vec2(0.0, 0.0); // 0\n    else varCoordsUV = vec2(1.0, 0.0);                // 1\n  }\n  else {\n    if (attIndex < 2.5) varCoordsUV = vec2(1.0, 1.0); // 2\n    else varCoordsUV = vec2(0.0, 1.0);                // 3\n  }\n}\n","fragment-a":"precision mediump float;\n// L'image de notre sprite.\nuniform sampler2D uniTexture;\n// Les coordonnes UV du pixel à dessiner.\n// (0,0) correspond au pixel en haut à gauche.\n// (1,1) correspond au pixel en bas à droite.\nvarying vec2 varCoordsUV;\n\nvoid main() {\n  // texture2D retourne la coleur à un endroit donné.\n  vec4 color = texture2D( uniTexture, varCoordsUV );\n  // Si le point est transparent, on ne l'affiche pas.\n  if ( color.a < 0.1 ) discard;\n  gl_FragColor = color;\n}\n","fragment-b":"const highp float PI = 3.1415926539;\nconst lowp vec3 COLOR0 = vec3(0.7, 0.9, 1.0);\nconst lowp vec3 COLOR1 = vec3(0.0, 0.7, 0.9);\n\nvarying lowp vec3 varVertexPosition;\n\nuniform lowp float uniTimeF;\n\nvoid main() {\n  highp float time = uniTimeF / 700.0;\n  \n  lowp float x = varVertexPosition.x + time * 120.0;\n  lowp float y = varVertexPosition.y + sin(time) * 15.0;\n  \n  lowp float xx = x / 10.0;\n  lowp float yy = y / 10.0;\n  \n  lowp float h = cos(yy) * cos(xx) + sin(yy);\n  h = cos( PI * h + time);\n  \n  h = (1.0 + h) / 2.0;\n  gl_FragColor = vec4( h * COLOR0 + (1.0 - h) * COLOR1, 1.0);\n}\n"};e("gfx");var d=e("dom"),f=e("tfw.data-binding"),h=function(e){var t=d.elem(this,"canvas");f.propInteger(this,"width")(function(e){t.setAttribute("width",e),t.style.width=e+"px"}),f.propInteger(this,"height")(function(e){t.setAttribute("height",e),t.style.height=e+"px"}),f.propString(this,"fragment"),e=f.extend({width:640,height:480,fragment:"a"},e,this),window.setTimeout(r.bind(this,t),20)};t.exports=h,t.exports._=l});
//# sourceMappingURL=wdg.gl5.js.map