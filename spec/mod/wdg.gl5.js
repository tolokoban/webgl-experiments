require("wdg.gl5",function(t,e){function n(){return s(f,arguments)}function r(t){function e(n){var r=o.createTexture();o.bindTexture(o.TEXTURE_2D,r),o.texParameteri(o.TEXTURE_2D,o.TEXTURE_WRAP_S,o.CLAMP_TO_EDGE),o.texParameteri(o.TEXTURE_2D,o.TEXTURE_WRAP_T,o.CLAMP_TO_EDGE),o.texParameteri(o.TEXTURE_2D,o.TEXTURE_MIN_FILTER,o.NEAREST),o.texParameteri(o.TEXTURE_2D,o.TEXTURE_MAG_FILTER,o.NEAREST),o.texImage2D(o.TEXTURE_2D,0,o.RGBA,o.RGBA,o.UNSIGNED_BYTE,p),o.uniform1f(P,t.width),o.uniform1f(b,t.height);var a=0;h.forEach(function(t,e){var r=t.x*f,o=s-Math.abs(Math.cos(t.y*Math.PI+n*t.scale/3613))*s,i=Math.cos(n*t.scale/2700),c=48*(1-.4*i),l=n*t.rotation/700;[0,1,3,2].forEach(function(t){T[a++]=r,T[a++]=o,T[a++]=i,T[a++]=t,T[a++]=c,T[a++]=l})}),o.bindBuffer(o.ARRAY_BUFFER,d),o.bufferData(o.ARRAY_BUFFER,T,o.STATIC_DRAW),o.clearColor(0,0,0,1),o.clear(o.COLOR_BUFFER_BIT|o.DEPTH_BUFFER_BIT);for(var i=0;i<u;i++)o.drawArrays(o.TRIANGLE_STRIP,4*i,4);window.requestAnimationFrame(e)}var n=A.vertex,r=A["fragment-"+this.fragment],o=t.getContext("webgl")||t.getContext("experimental-webgl"),i=o.createProgram();o.attachShader(i,l(o,n)),o.attachShader(i,c(o,r)),o.linkProgram(i),o.useProgram(i);var f=t.width,s=t.height,u=50,h=a(u),d=o.createBuffer(),T=new Float32Array(6*u*4),E=T.BYTES_PER_ELEMENT,v=6*E;o.bindBuffer(o.ARRAY_BUFFER,d);var x=o.getAttribLocation(i,"attPosition");o.enableVertexAttribArray(x),o.vertexAttribPointer(x,3,o.FLOAT,!1,v,0);var g=o.getAttribLocation(i,"attIndex");o.enableVertexAttribArray(g),o.vertexAttribPointer(g,1,o.FLOAT,!1,v,3*E);var m=o.getAttribLocation(i,"attScale");o.enableVertexAttribArray(m),o.vertexAttribPointer(m,1,o.FLOAT,!1,v,4*E);var R=o.getAttribLocation(i,"attRotation");o.enableVertexAttribArray(R),o.vertexAttribPointer(R,1,o.FLOAT,!1,v,5*E);var _=o.getAttribLocation(i,"attVertexPosition");o.enableVertexAttribArray(_),o.vertexAttribPointer(_,3,o.FLOAT,!1,0,0);var P=o.getUniformLocation(i,"uniWidth"),b=o.getUniformLocation(i,"uniHeight");o.disable(o.DEPTH_TEST);var p=new Image;p.onload=function(){window.requestAnimationFrame(e)},p.onerror=function(t){throw t},p.src="css/wdg.gl5/champi.png",o.enable(o.BLEND),o.blendFunc(o.SRC_ALPHA,o.ONE_MINUS_SRC_ALPHA),o.disable(o.DEPTH_TEST)}function a(t){for(var e=[];t-- >0;)e.push({x:o(0,1),y:o(0,1),z:o(.1,.9),size:o(20,100),scale:o(.7,3.2),rotation:o(-2,2)});return e}function o(t,e){return t+Math.random()*(e-t)}function i(t,e,n){var r=e.createShader(t);return e.shaderSource(r,n),e.compileShader(r),e.getShaderParameter(r,e.COMPILE_STATUS)?r:(console.log(n),console.error("An error occurred compiling the shader: "+e.getShaderInfoLog(r)),null)}function c(t,e){return i(t.FRAGMENT_SHADER,t,e)}function l(t,e){return i(t.VERTEX_SHADER,t,e)}var f={en:{}},s=require("$").intl,u=require("dom"),h=require("tfw.data-binding"),d=function(t){var e=u.elem(this,"canvas");h.propInteger(this,"width")(function(t){e.setAttribute("width",t),e.style.width=t+"px"}),h.propInteger(this,"height")(function(t){e.setAttribute("height",t),e.style.height=t+"px"}),h.propString(this,"fragment"),t=h.extend({width:640,height:480,fragment:"a"},t,this),window.setTimeout(r.bind(this,e),20)};e.exports=d;var A={vertex:"attribute vec3 attPosition;\n// Index du vertex (de 0.0 à 3.0).\nattribute float attIndex;\n// Angle de rotation.\nattribute float attRotation;\n// Facteur d'échelle.\nattribute float attScale;\n\nconst float PI = 3.1415926536;\n\nuniform float uniWidth;\nuniform float uniHeight;\n\nvarying vec2 varCoordsUV;\n\nvoid main() {\n  float x = attPosition.x \n    + attScale * cos( attRotation + attIndex * PI / 2.0 );\n  float y = attPosition.y\n    + attScale * sin( attRotation + attIndex * PI / 2.0 );\n\n  x = (2.0 * x / uniWidth) - 1.0;\n  y = 1.0 - (2.0 * y / uniHeight);\n\n  gl_Position = vec4( x, y, attPosition.z, 1.0 );\n\n  // Define a different color for each point.\n  if (attIndex == 0.0) varCoordsUV = vec2(0.0, 0.0);\n  else if (attIndex == 1.0) varCoordsUV = vec2(1.0, 0.0);\n  else if (attIndex == 2.0) varCoordsUV = vec2(1.0, 1.0);\n  else varCoordsUV = vec2(0.0, 1.0);\n}\n","fragment-a":"// Définir la précision par défaut\n// pour tous les floats.\nprecision mediump float;\n\nuniform sampler2D uniTexture;\n \nvarying vec2 varCoordsUV;\n\nvoid main() {\n  gl_FragColor = texture2D( uniTexture, varCoordsUV );\n}\n","fragment-b":"const highp float PI = 3.1415926539;\nconst lowp vec3 COLOR0 = vec3(0.7, 0.9, 1.0);\nconst lowp vec3 COLOR1 = vec3(0.0, 0.7, 0.9);\n\nvarying lowp vec3 varVertexPosition;\n\nuniform lowp float uniTimeF;\n\nvoid main() {\n  highp float time = uniTimeF / 700.0;\n  \n  lowp float x = varVertexPosition.x + time * 120.0;\n  lowp float y = varVertexPosition.y + sin(time) * 15.0;\n  \n  lowp float xx = x / 10.0;\n  lowp float yy = y / 10.0;\n  \n  lowp float h = cos(yy) * cos(xx) + sin(yy);\n  h = cos( PI * h + time);\n  \n  h = (1.0 + h) / 2.0;\n  gl_FragColor = vec4( h * COLOR0 + (1.0 - h) * COLOR1, 1.0);\n}\n"};e.exports._=n});
//# sourceMappingURL=wdg.gl5.js.map