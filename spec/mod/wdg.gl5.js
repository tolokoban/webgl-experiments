require("wdg.gl5",function(t,r){function e(){return s(f,arguments)}function n(t){function r(e){var n=o.createTexture();o.bindTexture(o.TEXTURE_2D,n),o.texParameteri(o.TEXTURE_2D,o.TEXTURE_WRAP_S,o.CLAMP_TO_EDGE),o.texParameteri(o.TEXTURE_2D,o.TEXTURE_WRAP_T,o.CLAMP_TO_EDGE),o.texParameteri(o.TEXTURE_2D,o.TEXTURE_MIN_FILTER,o.NEAREST),o.texParameteri(o.TEXTURE_2D,o.TEXTURE_MAG_FILTER,o.NEAREST),o.texImage2D(o.TEXTURE_2D,0,o.RGBA,o.RGBA,o.UNSIGNED_BYTE,p),o.uniform1f(P,t.width),o.uniform1f(b,t.height);var a=0;h.forEach(function(t,r){var n=t.x*f,o=s-Math.abs(Math.cos(t.y*Math.PI+e*t.scale/3613))*s,i=Math.cos(e*t.scale/2700),c=48*(1-.4*i),l=e*t.rotation/700;[0,1,3,2].forEach(function(t){T[a++]=n,T[a++]=o,T[a++]=i,T[a++]=t,T[a++]=c,T[a++]=l})}),o.bindBuffer(o.ARRAY_BUFFER,d),o.bufferData(o.ARRAY_BUFFER,T,o.STATIC_DRAW),o.clearColor(0,0,0,1),o.clear(o.COLOR_BUFFER_BIT|o.DEPTH_BUFFER_BIT);for(var i=0;i<u;i++)o.drawArrays(o.TRIANGLE_STRIP,4*i,4);window.requestAnimationFrame(r)}var e=A.vertex,n=A["fragment-"+this.fragment],o=t.getContext("webgl")||t.getContext("experimental-webgl"),i=o.createProgram();o.attachShader(i,l(o,e)),o.attachShader(i,c(o,n)),o.linkProgram(i),o.useProgram(i);var f=t.width,s=t.height,u=50,h=a(u),d=o.createBuffer(),T=new Float32Array(6*u*4),E=T.BYTES_PER_ELEMENT,v=6*E;o.bindBuffer(o.ARRAY_BUFFER,d);var x=o.getAttribLocation(i,"attPosition");o.enableVertexAttribArray(x),o.vertexAttribPointer(x,3,o.FLOAT,!1,v,0);var g=o.getAttribLocation(i,"attIndex");o.enableVertexAttribArray(g),o.vertexAttribPointer(g,1,o.FLOAT,!1,v,3*E);var m=o.getAttribLocation(i,"attScale");o.enableVertexAttribArray(m),o.vertexAttribPointer(m,1,o.FLOAT,!1,v,4*E);var R=o.getAttribLocation(i,"attRotation");o.enableVertexAttribArray(R),o.vertexAttribPointer(R,1,o.FLOAT,!1,v,5*E);var _=o.getAttribLocation(i,"attVertexPosition");o.enableVertexAttribArray(_),o.vertexAttribPointer(_,3,o.FLOAT,!1,0,0);var P=o.getUniformLocation(i,"uniWidth"),b=o.getUniformLocation(i,"uniHeight");o.disable(o.DEPTH_TEST);var p=new Image;p.onload=function(){window.requestAnimationFrame(r)},p.onerror=function(t){throw t},p.src="css/wdg.gl5/champi.png",o.enable(o.BLEND),o.blendFunc(o.SRC_ALPHA,o.ONE_MINUS_SRC_ALPHA),o.disable(o.DEPTH_TEST)}function a(t){for(var r=[];t-- >0;)r.push({x:o(0,1),y:o(0,1),z:o(.1,.9),size:o(20,100),scale:o(.7,3.2),rotation:o(-2,2)});return r}function o(t,r){return t+Math.random()*(r-t)}function i(t,r,e){var n=r.createShader(t);return r.shaderSource(n,e),r.compileShader(n),r.getShaderParameter(n,r.COMPILE_STATUS)?n:(console.log(e),console.error("An error occurred compiling the shader: "+r.getShaderInfoLog(n)),null)}function c(t,r){return i(t.FRAGMENT_SHADER,t,r)}function l(t,r){return i(t.VERTEX_SHADER,t,r)}var f={en:{}},s=require("$").intl,u=require("dom"),h=require("tfw.data-binding"),d=function(t){var r=u.elem(this,"canvas");h.propInteger(this,"width")(function(t){r.setAttribute("width",t),r.style.width=t+"px"}),h.propInteger(this,"height")(function(t){r.setAttribute("height",t),r.style.height=t+"px"}),h.propString(this,"fragment"),t=h.extend({width:640,height:480,fragment:"a"},t,this),window.setTimeout(n.bind(this,r),20)};r.exports=d;var A={vertex:"attribute vec3 attPosition;\r\n// Index du vertex (de 0.0 à 3.0).\r\nattribute float attIndex;\r\n// Angle de rotation.\r\nattribute float attRotation;\r\n// Facteur d'échelle.\r\nattribute float attScale;\r\n\r\nconst float PI = 3.1415926536;\r\n\r\nuniform float uniWidth;\r\nuniform float uniHeight;\r\n\r\nvarying vec2 varCoordsUV;\r\n\r\nvoid main() {\r\n  float x = attPosition.x \r\n    + attScale * cos( attRotation + attIndex * PI / 2.0 );\r\n  float y = attPosition.y\r\n    + attScale * sin( attRotation + attIndex * PI / 2.0 );\r\n\r\n  x = (2.0 * x / uniWidth) - 1.0;\r\n  y = 1.0 - (2.0 * y / uniHeight);\r\n\r\n  gl_Position = vec4( x, y, attPosition.z, 1.0 );\r\n\r\n  // Define a different color for each point.\r\n  if (attIndex == 0.0) varCoordsUV = vec2(0.0, 0.0);\r\n  else if (attIndex == 1.0) varCoordsUV = vec2(1.0, 0.0);\r\n  else if (attIndex == 2.0) varCoordsUV = vec2(1.0, 1.0);\r\n  else varCoordsUV = vec2(0.0, 1.0);\r\n}\r\n","fragment-a":"// Définir la précision par défaut\r\n// pour tous les floats.\r\nprecision mediump float;\r\n\r\nuniform sampler2D uniTexture;\r\n \r\nvarying vec2 varCoordsUV;\r\n\r\nvoid main() {\r\n  gl_FragColor = texture2D( uniTexture, varCoordsUV );\r\n}\r\n","fragment-b":"const highp float PI = 3.1415926539;\r\nconst lowp vec3 COLOR0 = vec3(0.7, 0.9, 1.0);\r\nconst lowp vec3 COLOR1 = vec3(0.0, 0.7, 0.9);\r\n\r\nvarying lowp vec3 varVertexPosition;\r\n\r\nuniform lowp float uniTimeF;\r\n\r\nvoid main() {\r\n  highp float time = uniTimeF / 700.0;\r\n  \r\n  lowp float x = varVertexPosition.x + time * 120.0;\r\n  lowp float y = varVertexPosition.y + sin(time) * 15.0;\r\n  \r\n  lowp float xx = x / 10.0;\r\n  lowp float yy = y / 10.0;\r\n  \r\n  lowp float h = cos(yy) * cos(xx) + sin(yy);\r\n  h = cos( PI * h + time);\r\n  \r\n  h = (1.0 + h) / 2.0;\r\n  gl_FragColor = vec4( h * COLOR0 + (1.0 - h) * COLOR1, 1.0);\r\n}\r\n"};r.exports._=e});
//# sourceMappingURL=wdg.gl5.js.map