<<<<<<< HEAD
require("wdg.gl6-2",function(e,n){function r(){return s(u,arguments)}function t(e){function n(e){window.requestAnimationFrame(n);var t,o,i,l,g=e/1766.781248,A=Math.cos(g),h=Math.sin(g),v=e/1979.998511,E=Math.cos(v),_=Math.sin(v),R=A,b=0,p=h,F=h*_,P=E,T=-A*_,C=-h*E,m=_,S=A*E;for(l=0;l<u;l++)t=c[3*l+0],o=c[3*l+1],i=c[3*l+2],s[6*l+0]=t*R+o*b+i*p,s[6*l+1]=t*F+o*P+i*T,s[6*l+2]=t*C+o*m+i*S;d.sort(function(e,n){return s[6*n+2]-s[6*e+2]}),r.bindBuffer(r.ARRAY_BUFFER,a),r.bufferData(r.ARRAY_BUFFER,s,r.STATIC_DRAW),r.bindBuffer(r.ELEMENT_ARRAY_BUFFER,f),r.bufferData(r.ELEMENT_ARRAY_BUFFER,d,r.STATIC_DRAW),r.clear(r.COLOR_BUFFER_BIT|r.DEPTH_BUFFER_BIT),r.drawElements(r.POINTS,u,r.UNSIGNED_SHORT,0)}var r=e.getContext("webgl")||e.getContext("experimental-webgl"),t=r.createProgram();r.attachShader(t,i(r,g.vertex)),r.attachShader(t,o(r,g.fragment)),r.linkProgram(t),r.useProgram(t);var a=r.createBuffer();r.bindBuffer(r.ARRAY_BUFFER,a);var u=56,s=new Float32Array(6*u);r.bufferData(r.ARRAY_BUFFER,s,r.STATIC_DRAW);var c=[],d=new Uint16Array(u),f=r.createBuffer();r.bindBuffer(r.ELEMENT_ARRAY_BUFFER,f),r.bufferData(r.ELEMENT_ARRAY_BUFFER,d,r.STATIC_DRAW),function(){var e,n,r,t,a,o,i,f,g=6;for(n=0;n<u-g;n++)e=l(),s[6*n+3]=e.r,s[6*n+4]=e.g,s[6*n+5]=e.b,d[n]=n,i=.2*Math.PI+.6*n*Math.PI/(u-g-1),f=8.7*n*Math.PI/(u-g-1),a=Math.cos(i),o=Math.sin(i),r=o*Math.cos(f),t=o*Math.sin(f),c.push(r,t,a);for(n=u-g;n<u;n++)e=l(),d[n]=n,s[6*n+3]=e.r,s[6*n+4]=e.g,s[6*n+5]=e.b,c.push(0,0,2*(n-u+g)/(g-1)-1)}();var A=s.BYTES_PER_ELEMENT,h=6*A,v=r.getAttribLocation(t,"attPosition");r.enableVertexAttribArray(v),r.vertexAttribPointer(v,3,r.FLOAT,!1,h,0);var E=r.getAttribLocation(t,"attColor");r.enableVertexAttribArray(E),r.vertexAttribPointer(E,3,r.FLOAT,!1,h,3*A),Boolean(this.zbuffer)?(r.enable(r.DEPTH_TEST),r.depthFunc(r.LEQUAL),r.disable(r.BLEND),r.enable(r.BLEND),r.blendFunc(r.SRC_ALPHA,r.ONE_MINUS_SRC_ALPHA)):(r.enable(r.BLEND),r.blendFunc(r.SRC_ALPHA,r.ONE_MINUS_SRC_ALPHA),r.disable(r.DEPTH_TEST)),r.clearColor(0,0,0,1),r.bindBuffer(r.ARRAY_BUFFER,a),window.requestAnimationFrame(n)}function a(e,n,r){var t=n.createShader(e);return n.shaderSource(t,r),n.compileShader(t),n.getShaderParameter(t,n.COMPILE_STATUS)?t:(console.log(r),console.error("An error occurred compiling the shader: "+n.getShaderInfoLog(t)),null)}function o(e,n){return a(e.FRAGMENT_SHADER,e,n)}function i(e,n){return a(e.VERTEX_SHADER,e,n)}function l(){var e=Math.random(),n=Math.random(),r=Math.random();return e<n?r<e?(e=1,r=0):(e=1,n>r?r=0:n=0):n>r?(e=1,r=0):(n=0,e>r?e=1:r=1),{r:e,g:n,b:r}}var u={en:{}},s=require("$").intl,c=require("dom"),d=require("tfw.data-binding"),f=function(e){var n=c.elem(this,"canvas");d.propInteger(this,"width")(function(e){n.setAttribute("width",e),n.style.width=e+"px"}),d.propInteger(this,"height")(function(e){n.setAttribute("height",e),n.style.height=e+"px"}),d.propBoolean(this,"zindex"),e=d.extend({width:640,height:480,zbuffer:!1},e,this),window.setTimeout(t.bind(this,n),20)};n.exports=f;var g={vertex:"attribute vec3 attPosition;\nattribute vec3 attColor;\n\nvarying vec3 varPosition;\nvarying vec3 varColor;\n\nvoid main() {\n  float z = attPosition.z;\n  // Dans une projection 3D, les points éloignés de la caméra\n  // paraissent plus petits et plus proches les uns des autres.\n  // Cette variable permet de créer cet effet.\n  float depth = (1.5 - z) / 2.5;\n  gl_Position = vec4(attPosition.xy * depth, z, 1.0);\n\n  // La taille du point dépend aussi de la profondeur.\n  gl_PointSize = 80.0 * depth;\n  varPosition = attPosition;\n  varColor = attColor;\n}\n",fragment:"precision mediump float;\n\nvarying vec3 varPosition;\nvarying vec3 varColor;\n\nconst vec3 WHITE = vec3(1.0, 1.0, 1.0);\n\nvoid main() {\n  // Calculons la distance du fragment courant\n  // au centre du point.\n  float x = gl_PointCoord.x - 0.5;\n  float y = gl_PointCoord.y - 0.5;\n  // On ne calcule pas la racine carré pour gagner du temps.\n  float r = x*x + y*y;\n\n  x = gl_PointCoord.x;\n  y = gl_PointCoord.y;\n\n  // 0.25 = 0.5 * 0.5\n  if (r > 0.25) {\n    // Si on est à l'extérieur du cercle de rayon 0.5,\n    // on place un fragment transparent.\n    gl_FragColor = vec4( 0.0, 0.0, 0.0, 0.0 );\n  } else if (r > .2 ) {\n    // Au delà d'un certain rayon, on met une couleur fixe\n    // qui nous sert de liseré.\n    gl_FragColor = vec4(varColor, 1.0);\n  } else {\n    // Petit effet de dégradé.\n    vec3 col = x * varColor + y * WHITE;\n    gl_FragColor = vec4( col, 0.9 );\n  }\n  // La luminosité varie avec la profondeur du point.\n  // En `z = 0.0`, la boule est noire.\n  gl_FragColor = vec4( gl_FragColor.rgb * (1.0 - varPosition.z) / 2.0, gl_FragColor.a);\n}\n"};n.exports._=r});
=======
require("wdg.gl6-2",function(r,e,n){function t(r){function e(r){window.requestAnimationFrame(e);var t,o,i,l,s=r/1766.781248,A=Math.cos(s),h=Math.sin(s),v=r/1979.998511,E=Math.cos(v),_=Math.sin(v),R=A,b=h,p=h*_,F=E,P=-A*_,T=-h*E,C=_,m=A*E;for(l=0;l<u;l++)t=d[3*l+0],o=d[3*l+1],i=d[3*l+2],c[6*l+0]=t*R+0*o+i*b,c[6*l+1]=t*p+o*F+i*P,c[6*l+2]=t*T+o*C+i*m;f.sort(function(r,e){return c[6*e+2]-c[6*r+2]}),n.bindBuffer(n.ARRAY_BUFFER,a),n.bufferData(n.ARRAY_BUFFER,c,n.STATIC_DRAW),n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,g),n.bufferData(n.ELEMENT_ARRAY_BUFFER,f,n.STATIC_DRAW),n.clear(n.COLOR_BUFFER_BIT|n.DEPTH_BUFFER_BIT),n.drawElements(n.POINTS,u,n.UNSIGNED_SHORT,0)}var n=r.getContext("webgl")||r.getContext("experimental-webgl"),t=n.createProgram();n.attachShader(t,i(n,s.vertex)),n.attachShader(t,o(n,s.fragment)),n.linkProgram(t),n.useProgram(t);var a=n.createBuffer();n.bindBuffer(n.ARRAY_BUFFER,a);var u=56,c=new Float32Array(6*u);n.bufferData(n.ARRAY_BUFFER,c,n.STATIC_DRAW);var d=[],f=new Uint16Array(u),g=n.createBuffer();n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,g),n.bufferData(n.ELEMENT_ARRAY_BUFFER,f,n.STATIC_DRAW),function(){var r,e,n,t,a,o,i,s;for(e=0;e<u-6;e++)r=l(),c[6*e+3]=r.r,c[6*e+4]=r.g,c[6*e+5]=r.b,f[e]=e,i=.2*Math.PI+.6*e*Math.PI/(u-6-1),s=8.7*e*Math.PI/(u-6-1),a=Math.cos(i),o=Math.sin(i),n=o*Math.cos(s),t=o*Math.sin(s),d.push(n,t,a);for(e=u-6;e<u;e++)r=l(),f[e]=e,c[6*e+3]=r.r,c[6*e+4]=r.g,c[6*e+5]=r.b,d.push(0,0,2*(e-u+6)/5-1)}();var A=c.BYTES_PER_ELEMENT,h=6*A,v=n.getAttribLocation(t,"attPosition");n.enableVertexAttribArray(v),n.vertexAttribPointer(v,3,n.FLOAT,!1,h,0);var E=n.getAttribLocation(t,"attColor");n.enableVertexAttribArray(E),n.vertexAttribPointer(E,3,n.FLOAT,!1,h,3*A),Boolean(this.zbuffer)?(n.enable(n.DEPTH_TEST),n.depthFunc(n.LEQUAL),n.disable(n.BLEND),n.enable(n.BLEND),n.blendFunc(n.SRC_ALPHA,n.ONE_MINUS_SRC_ALPHA)):(n.enable(n.BLEND),n.blendFunc(n.SRC_ALPHA,n.ONE_MINUS_SRC_ALPHA),n.disable(n.DEPTH_TEST)),n.clearColor(0,0,0,1),n.bindBuffer(n.ARRAY_BUFFER,a),window.requestAnimationFrame(e)}function a(r,e,n){var t=e.createShader(r);return e.shaderSource(t,n),e.compileShader(t),e.getShaderParameter(t,e.COMPILE_STATUS)?t:(console.log(n),console.error("An error occurred compiling the shader: "+e.getShaderInfoLog(t)),null)}function o(r,e){return a(r.FRAGMENT_SHADER,r,e)}function i(r,e){return a(r.VERTEX_SHADER,r,e)}function l(){var r=Math.random(),e=Math.random(),n=Math.random();return r<e?n<r?(r=1,n=0):(r=1,e>n?n=0:e=0):e>n?(r=1,n=0):(e=0,r>n?r=1:n=1),{r:r,g:e,b:n}}var u=function(){function e(){return t(n,arguments)}var n={en:{}},t=r("$").intl;return e.all=n,e}(),s={vertex:"attribute vec3 attPosition;\r\nattribute vec3 attColor;\r\n\r\nvarying vec3 varPosition;\r\nvarying vec3 varColor;\r\n\r\nvoid main() {\r\n  float z = attPosition.z;\r\n  // Dans une projection 3D, les points éloignés de la caméra\r\n  // paraissent plus petits et plus proches les uns des autres.\r\n  // Cette variable permet de créer cet effet.\r\n  float depth = (1.5 - z) / 2.5;\r\n  gl_Position = vec4(attPosition.xy * depth, z, 1.0);\r\n\r\n  // La taille du point dépend aussi de la profondeur.\r\n  gl_PointSize = 80.0 * depth;\r\n  varPosition = attPosition;\r\n  varColor = attColor;\r\n}\r\n",fragment:"precision mediump float;\r\n\r\nvarying vec3 varPosition;\r\nvarying vec3 varColor;\r\n\r\nconst vec3 WHITE = vec3(1.0, 1.0, 1.0);\r\n\r\nvoid main() {\r\n  // Calculons la distance du fragment courant\r\n  // au centre du point.\r\n  float x = gl_PointCoord.x - 0.5;\r\n  float y = gl_PointCoord.y - 0.5;\r\n  // On ne calcule pas la racine carré pour gagner du temps.\r\n  float r = x*x + y*y;\r\n\r\n  x = gl_PointCoord.x;\r\n  y = gl_PointCoord.y;\r\n\r\n  // 0.25 = 0.5 * 0.5\r\n  if (r > 0.25) {\r\n    // Si on est à l'extérieur du cercle de rayon 0.5,\r\n    // on place un fragment transparent.\r\n    gl_FragColor = vec4( 0.0, 0.0, 0.0, 0.0 );\r\n  } else if (r > .2 ) {\r\n    // Au delà d'un certain rayon, on met une couleur fixe\r\n    // qui nous sert de liseré.\r\n    gl_FragColor = vec4(varColor, 1.0);\r\n  } else {\r\n    // Petit effet de dégradé.\r\n    vec3 col = x * varColor + y * WHITE;\r\n    gl_FragColor = vec4( col, 0.9 );\r\n  }\r\n  // La luminosité varie avec la profondeur du point.\r\n  // En `z = 0.0`, la boule est noire.\r\n  gl_FragColor = vec4( gl_FragColor.rgb * (1.0 - varPosition.z) / 2.0, gl_FragColor.a);\r\n}\r\n"},c=r("dom"),d=r("tfw.data-binding"),f=function(r){var e=c.elem(this,"canvas");d.propInteger(this,"width")(function(r){e.setAttribute("width",r),e.style.width=r+"px"}),d.propInteger(this,"height")(function(r){e.setAttribute("height",r),e.style.height=r+"px"}),d.propBoolean(this,"zindex"),r=d.extend({width:640,height:480,zbuffer:!1},r,this),window.setTimeout(t.bind(this,e),20)};e.exports=f,e.exports._=u});
>>>>>>> ed60770fef43ceb6207a072673d058559ad5436c
//# sourceMappingURL=wdg.gl6-2.js.map