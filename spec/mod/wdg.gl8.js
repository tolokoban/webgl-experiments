require("wdg.gl8",function(e,n){function t(){return i(o,arguments)}function a(e,n){var t=new s({canvas:e}),a=t.gl,o=t.createProgram({vertex:d.vertex,fragment:d.fragment}),i=a.createBuffer();a.bindBuffer(a.ARRAY_BUFFER,i);var l=r(t,n),u=l.length/6;a.bufferData(a.ARRAY_BUFFER,l,a.STATIC_DRAW);var f=l.BYTES_PER_ELEMENT,R=6*f;a.disable(a.DEPTH_TEST),a.enable(a.BLEND),a.blendFuncSeparate(a.SRC_ALPHA,a.ONE_MINUS_SRC_ALPHA,a.ZERO,a.ONE),a.blendEquation(a.FUNC_ADD);var E=a.createFramebuffer();a.bindFramebuffer(a.FRAMEBUFFER,E);var c=a.createTexture();a.bindTexture(a.TEXTURE_2D,c),a.texParameteri(a.TEXTURE_2D,a.TEXTURE_MAG_FILTER,a.LINEAR),a.texParameteri(a.TEXTURE_2D,a.TEXTURE_MIN_FILTER,a.LINEAR_MIPMAP_NEAREST),a.generateMipmap(a.TEXTURE_2D),a.texImage2D(a.TEXTURE_2D,0,a.RGBA,512,512,0,a.RGBA,a.UNSIGNED_BYTE,null),a.framebufferTexture2D(a.FRAMEBUFFER,a.COLOR_ATTACHMENT0,a.TEXTURE_2D,c,0);var m=a.createRenderbuffer();a.bindRenderbuffer(a.RENDERBUFFER,m),a.renderbufferStorage(a.RENDERBUFFER,a.DEPTH_COMPONENT16,512,512),a.framebufferRenderbuffer(a.FRAMEBUFFER,a.DEPTH_ATTACHMENT,a.RENDERBUFFER,m),a.bindTexture(a.TEXTURE_2D,null),a.bindRenderbuffer(a.RENDERBUFFER,null),a.bindFramebuffer(a.FRAMEBUFFER,null);var T=t.createProgram({vertex:d.vertex2,fragment:d.fragment2}),v=a.createBuffer();a.bindBuffer(a.ARRAY_BUFFER,v),a.bufferData(a.ARRAY_BUFFER,new Float32Array([-1,-1,-1,1,1,-1,1,1]),a.STATIC_DRAW),a.enableVertexAttribArray(T.$attPosition),a.vertexAttribPointer(T.$attPosition,2,a.FLOAT,!1,2*f,0),a.clearColor(1,1,1,1),t.start(function(e){o.use(),a.bindFramebuffer(a.FRAMEBUFFER,E),a.bindBuffer(a.ARRAY_BUFFER,i),a.bufferData(a.ARRAY_BUFFER,l,a.STATIC_DRAW),a.enableVertexAttribArray(o.$attPosition),a.vertexAttribPointer(o.$attPosition,2,a.FLOAT,!1,R,0),a.enableVertexAttribArray(o.$attRandom),a.vertexAttribPointer(o.$attRandom,4,a.FLOAT,!1,R,2*f),a.uniform1f(o.$uniTime,e),a.disable(a.DEPTH_TEST),a.enable(a.BLEND),a.blendFuncSeparate(a.SRC_ALPHA,a.ONE_MINUS_SRC_ALPHA,a.ZERO,a.ONE),a.blendEquation(a.FUNC_ADD),a.drawArrays(a.POINTS,0,u),a.bindFramebuffer(a.FRAMEBUFFER,null),T.use(),a.viewport(0,0,a.viewportWidth,a.viewportHeight),a.clear(a.COLOR_BUFFER_BIT|a.DEPTH_BUFFER_BIT),a.activeTexture(a.TEXTURE0),a.bindTexture(a.TEXTURE_2D,c),a.bindBuffer(a.ARRAY_BUFFER,v),a.drawArrays(a.POINTS,0,4)})}function r(e,n){var t,a,r=0,o=e.getDataFromImage(n),i=[];for(a=0;a<n.height;a++)for(t=0;t<n.width;t++)o[r]+o[r+1]+o[r+2]<50&&o[r+3]>240&&i.push([2*t/n.width-1,1-2*a/n.height]),r+=4;var l=(i.length,[]);return i.forEach(function(e){l.push(e[0]),l.push(e[1]),l.push(Math.random()),l.push(Math.random()),l.push(Math.random()),l.push(Math.random())}),new Float32Array(l)}var o={en:{}},i=require("$").intl,l=require("dom"),u=require("tfw.data-binding"),s=require("tfw.webgl"),f=function(e){var n=l.elem(this,"canvas");u.propInteger(this,"width")(function(e){n.setAttribute("width",e),n.style.width=e+"px"}),u.propInteger(this,"height")(function(e){n.setAttribute("height",e),n.style.height=e+"px"}),e=u.extend({width:640,height:480},e,this);var t=new Image;t.src="css/wdg.gl7/tp.png",t.onload=a.bind(this,n,t)};n.exports=f;var d={vertex:'// Temps courant en millisecondes\nuniform float uniTime;\n\n// Position en valeurs comprises entre -1.0 et +1.0\nattribute vec2 attPosition;\n// 4 Valeurs aléatoires comprises entre 0.0 et 1.0\n// Ces valeurs donnent la "personnalité" de la particule\nattribute vec4 attRandom;\n\n// Couleur pour le fragment shader\nvarying vec3 varColor;\n// Indique au fragment shader si les particules sont\n// en place (1.0) ou en mouvement désordonné (0.0)\nvarying float varCoeff;\n\nvoid main() {\n  float t = dot(attRandom, attRandom) * 10000.0 + uniTime / 100.0;\n  // Position "en place" de la particule.\n  float x = attPosition.x;\n  float y = attPosition.y;\n\n  // Créer un léger mouvement autour de la position normale.\n  float radius = .02 * cos(t * attRandom.y);\n  float ang = uniTime * attRandom.z / 100.0;\n  x = x + radius * cos(ang);\n  y = y + radius * sin(ang);\n\n  // Coordonnées aléatoires en rotation dans tout l\'espace.\n  radius = 1.5 * sin(t * 0.01 * (attRandom.y + attRandom.x));\n  ang = t * attRandom.x * 0.1;\n  float xx = radius * cos(ang);\n  float yy = radius * sin(ang);\n\n  // Dans un cycle de 12 secondes, l\'image est stable\n  // pendant 8 secondes et en vrac pendant 4.\n  float c1 = 0.0;\n  float tt = mod(uniTime, 12000.0);\n  if (tt < 4000.0) {\n    c1 = sin(tt * 3.1415926539 / 4000.0);\n  }\n  float c2 = 1.0 - c1;\n\n  varCoeff = c2;\n  // Petites variations de vert.\n  varColor = vec3( 0.0, .3 + .1 * abs(cos(attRandom.x * uniTime * 0.01)), 0.0 );\n  // La position est intrerpolée entre (x,y) et (xx,yy).\n  gl_Position = vec4( x * c2 + xx * c1, y * c2 + yy * c1, 0.0, 1.0 );\n  // Palpitation de la taille et diminution lors de la phase de désordre.\n  ang = t * attRandom.x;\n  gl_PointSize = max(8.0, (32.0 + 8.0 * cos(ang)) * (.5 + c2 * .5));\n}\n',fragment:"precision mediump float;\n\nvarying vec3 varColor;\nvarying float varCoeff;\n\nvoid main() {\n  // Calculons la distance du fragment courant\n  // au centre du point.\n  float x = gl_PointCoord.x - 0.5;\n  float y = gl_PointCoord.y - 0.5;\n  // On ne calcule pas la racine carré pour gagner du temps.\n  float r = x*x + y*y;\n  float alpha = clamp(1.0 - r * 4.0, 0.0, 1.0);\n\n  gl_FragColor = vec4( varColor, alpha * (1.0 - varCoeff * 0.3) );\n}\n",vertex2:"// Temps courant en millisecondes\nuniform float uniTime;\n\n// Position en valeurs comprises entre -1.0 et +1.0\nattribute vec2 attPosition;\n\n// Passer les coordonnées UV pour la texture.\nvarying vec2 varUV;\n\nvoid main() {\n  float x = attPosition.x;\n  float y = attPosition.y;\n  float z = 0.0;\n\n  gl_Position = vec4(x, y, z, 1.0 );\n\n  float u = (x + 1.0) / 2.0;\n  float v = (1.0 - y) / 2.0;\n  varUV = vec2( u, v );\n}\n",fragment2:"precision mediump float;\n\nuniform sampler2D uniTexture;\n\nvarying vec2 varUV;\n\nvoid main() {\n  gl_FragColor = texture2D( uniTexture, varUV );\n  gl_FragColor = vec4(1.0, .9, .9, 1.0);\n}\n"};n.exports._=t});
//# sourceMappingURL=wdg.gl8.js.map