<<<<<<< HEAD
require("wdg.gl7",function(t,n){function e(){return d(s,arguments)}function a(t,n){function e(t){window.requestAnimationFrame(e),a.clear(a.COLOR_BUFFER_BIT),a.uniform1f(E,t),a.drawArrays(a.POINTS,0,v)}var a=t.getContext("webgl")||t.getContext("experimental-webgl"),r=a.createProgram();a.attachShader(r,i(a,g.vertex)),a.attachShader(r,o(a,g.fragment)),a.linkProgram(r),a.useProgram(r);for(var s=a.getProgramParameter(r,a.ACTIVE_ATTRIBUTES),d=0;d<s;d++)console.log(a.getActiveAttrib(r,d));var u=a.createBuffer();a.bindBuffer(a.ARRAY_BUFFER,u);var c,m,f=0,h=l(n),p=[];for(m=0;m<n.height;m++)for(c=0;c<n.width;c++)h[f]+h[f+1]+h[f+2]<50&&h[f+3]>240&&p.push([2*c/n.width-1,1-2*m/n.height]),f+=4;var v=p.length,A=[];p.forEach(function(t){A.push(t[0]),A.push(t[1]),A.push(Math.random()),A.push(Math.random()),A.push(Math.random()),A.push(Math.random())});var x=new Float32Array(A);a.bufferData(a.ARRAY_BUFFER,x,a.STATIC_DRAW);var R=x.BYTES_PER_ELEMENT,b=6*R,y=a.getAttribLocation(r,"attPosition");a.enableVertexAttribArray(y),a.vertexAttribPointer(y,2,a.FLOAT,!1,b,0);var C=a.getAttribLocation(r,"attRandom");a.enableVertexAttribArray(C),a.vertexAttribPointer(C,4,a.FLOAT,!1,b,2*R),a.disable(a.DEPTH_TEST),a.enable(a.BLEND),a.blendFuncSeparate(a.SRC_ALPHA,a.ONE_MINUS_SRC_ALPHA,a.ZERO,a.ONE),a.blendEquation(a.FUNC_ADD);var E=a.getUniformLocation(r,"uniTime");a.clearColor(1,1,1,1),a.bindBuffer(a.ARRAY_BUFFER,u),window.requestAnimationFrame(e)}function r(t,n,e){var a=n.createShader(t);return n.shaderSource(a,e),n.compileShader(a),n.getShaderParameter(a,n.COMPILE_STATUS)?a:(console.log(e),console.error("An error occurred compiling the shader: "+n.getShaderInfoLog(a)),null)}function o(t,n){return r(t.FRAGMENT_SHADER,t,n)}function i(t,n){return r(t.VERTEX_SHADER,t,n)}function l(t){var n=t.width,e=t.height,a=document.createElement("canvas");a.setAttribute("width",n),a.setAttribute("height",e);var r=a.getContext("2d");return r.drawImage(t,0,0),document.body.appendChild(a),r.getImageData(0,0,n,e).data}var s={en:{}},d=require("$").intl,u=require("dom"),c=require("tfw.data-binding"),m=function(t){var n=u.elem(this,"canvas");c.propInteger(this,"width")(function(t){n.setAttribute("width",t),n.style.width=t+"px"}),c.propInteger(this,"height")(function(t){n.setAttribute("height",t),n.style.height=t+"px"}),c.propBoolean(this,"zindex"),t=c.extend({width:640,height:480,zbuffer:!1},t,this);var e=new Image;e.src="css/wdg.gl7/tp.png",e.onload=a.bind(this,n,e)};n.exports=m;var g={vertex:'// Temps courant en millisecondes\nuniform float uniTime;\n\n// Position en valeurs comprises entre -1.0 et +1.0\nattribute vec2 attPosition;\n// 4 Valeurs aléatoires comprises entre 0.0 et 1.0\n// Ces valeurs donnent la "personnalité" de la particule\nattribute vec4 attRandom;\n\n// Couleur pour le fragment shader\nvarying vec3 varColor;\n// Indique au fragment shader si les particules sont\n// en place (1.0) ou en mouvement désordonné (0.0)\nvarying float varCoeff;\n\nvoid main() {\n  float t = dot(attRandom, attRandom) * 10000.0 + uniTime / 100.0;\n  // Position "en place" de la particule.\n  float x = attPosition.x;\n  float y = attPosition.y;\n\n  // Créer un léger mouvement autour de la position normale.\n  float radius = .02 * cos(t * attRandom.y);\n  float ang = uniTime * attRandom.z / 100.0;\n  x = x + radius * cos(ang);\n  y = y + radius * sin(ang);\n\n  // Coordonnées aléatoires en rotation dans tout l\'espace.\n  radius = 1.5 * sin(t * 0.01 * (attRandom.y + attRandom.x));\n  ang = t * attRandom.x * 0.1;\n  float xx = radius * cos(ang);\n  float yy = radius * sin(ang);\n\n  // Dans un cycle de 12 secondes, l\'image est stable\n  // pendant 8 secondes et en vrac pendant 4.\n  float c1 = 0.0;\n  float tt = mod(uniTime, 12000.0);\n  if (tt < 4000.0) {\n    c1 = sin(tt * 3.1415926539 / 4000.0);\n  }\n  float c2 = 1.0 - c1;\n\n  varCoeff = c2;\n  // Petites variations de vert.\n  varColor = vec3( 0.0, .3 + .1 * abs(cos(attRandom.x * uniTime * 0.01)), 0.0 );\n  // La position est intrerpolée entre (x,y) et (xx,yy).\n  gl_Position = vec4( x * c2 + xx * c1, y * c2 + yy * c1, 0.0, 1.0 );\n  // Palpitation de la taille et diminution lors de la phase de désordre.\n  ang = t * attRandom.x;\n  gl_PointSize = max(8.0, (32.0 + 8.0 * cos(ang)) * (.5 + c2 * .5));\n}\n',fragment:"precision mediump float;\n\nvarying vec3 varColor;\nvarying float varCoeff;\n\nvoid main() {\n  // Calculons la distance du fragment courant\n  // au centre du point.\n  float x = gl_PointCoord.x - 0.5;\n  float y = gl_PointCoord.y - 0.5;\n  // On ne calcule pas la racine carré pour gagner du temps.\n  float r = x*x + y*y;\n  float alpha = clamp(1.0 - r * 4.0, 0.0, 1.0);\n\n  gl_FragColor = vec4( varColor, alpha * (1.0 - varCoeff * 0.3) );\n}\n"};n.exports._=e});
=======
require("wdg.gl7",function(r,t,n){function e(r,t){function n(r){window.requestAnimationFrame(n),e.clear(e.COLOR_BUFFER_BIT),e.uniform1f(E,r),e.drawArrays(e.POINTS,0,v)}var e=r.getContext("webgl")||r.getContext("experimental-webgl"),a=e.createProgram();e.attachShader(a,i(e,d.vertex)),e.attachShader(a,o(e,d.fragment)),e.linkProgram(a),e.useProgram(a);for(var s=e.getProgramParameter(a,e.ACTIVE_ATTRIBUTES),u=0;u<s;u++)console.log(e.getActiveAttrib(a,u));var c=e.createBuffer();e.bindBuffer(e.ARRAY_BUFFER,c);var m,g,f=0,h=l(t),p=[];for(g=0;g<t.height;g++)for(m=0;m<t.width;m++)h[f]+h[f+1]+h[f+2]<50&&h[f+3]>240&&p.push([2*m/t.width-1,1-2*g/t.height]),f+=4;var v=p.length,A=[];p.forEach(function(r){A.push(r[0]),A.push(r[1]),A.push(Math.random()),A.push(Math.random()),A.push(Math.random()),A.push(Math.random())});var x=new Float32Array(A);e.bufferData(e.ARRAY_BUFFER,x,e.STATIC_DRAW);var R=x.BYTES_PER_ELEMENT,b=6*R,y=e.getAttribLocation(a,"attPosition");e.enableVertexAttribArray(y),e.vertexAttribPointer(y,2,e.FLOAT,!1,b,0);var C=e.getAttribLocation(a,"attRandom");e.enableVertexAttribArray(C),e.vertexAttribPointer(C,4,e.FLOAT,!1,b,2*R),e.disable(e.DEPTH_TEST),e.enable(e.BLEND),e.blendFuncSeparate(e.SRC_ALPHA,e.ONE_MINUS_SRC_ALPHA,e.ZERO,e.ONE),e.blendEquation(e.FUNC_ADD);var E=e.getUniformLocation(a,"uniTime");e.clearColor(1,1,1,1),e.bindBuffer(e.ARRAY_BUFFER,c),window.requestAnimationFrame(n)}function a(r,t,n){var e=t.createShader(r);return t.shaderSource(e,n),t.compileShader(e),t.getShaderParameter(e,t.COMPILE_STATUS)?e:(console.log(n),console.error("An error occurred compiling the shader: "+t.getShaderInfoLog(e)),null)}function o(r,t){return a(r.FRAGMENT_SHADER,r,t)}function i(r,t){return a(r.VERTEX_SHADER,r,t)}function l(r){var t=r.width,n=r.height,e=document.createElement("canvas");e.setAttribute("width",t),e.setAttribute("height",n);var a=e.getContext("2d");return a.drawImage(r,0,0),document.body.appendChild(e),a.getImageData(0,0,t,n).data}var s=function(){function t(){return e(n,arguments)}var n={en:{}},e=r("$").intl;return t.all=n,t}(),d={vertex:'// Temps courant en millisecondes\r\nuniform float uniTime;\r\n\r\n// Position en valeurs comprises entre -1.0 et +1.0\r\nattribute vec2 attPosition;\r\n// 4 Valeurs aléatoires comprises entre 0.0 et 1.0\r\n// Ces valeurs donnent la "personnalité" de la particule\r\nattribute vec4 attRandom;\r\n\r\n// Couleur pour le fragment shader\r\nvarying vec3 varColor;\r\n// Indique au fragment shader si les particules sont\r\n// en place (1.0) ou en mouvement désordonné (0.0)\r\nvarying float varCoeff;\r\n\r\nvoid main() {\r\n  float t = dot(attRandom, attRandom) * 10000.0 + uniTime / 100.0;\r\n  // Position "en place" de la particule.\r\n  float x = attPosition.x;\r\n  float y = attPosition.y;\r\n\r\n  // Créer un léger mouvement autour de la position normale.\r\n  float radius = .02 * cos(t * attRandom.y);\r\n  float ang = uniTime * attRandom.z / 100.0;\r\n  x = x + radius * cos(ang);\r\n  y = y + radius * sin(ang);\r\n\r\n  // Coordonnées aléatoires en rotation dans tout l\'espace.\r\n  radius = 1.5 * sin(t * 0.01 * (attRandom.y + attRandom.x));\r\n  ang = t * attRandom.x * 0.1;\r\n  float xx = radius * cos(ang);\r\n  float yy = radius * sin(ang);\r\n\r\n  // Dans un cycle de 12 secondes, l\'image est stable\r\n  // pendant 8 secondes et en vrac pendant 4.\r\n  float c1 = 0.0;\r\n  float tt = mod(uniTime, 12000.0);\r\n  if (tt < 4000.0) {\r\n    c1 = sin(tt * 3.1415926539 / 4000.0);\r\n  }\r\n  float c2 = 1.0 - c1;\r\n\r\n  varCoeff = c2;\r\n  // Petites variations de vert.\r\n  varColor = vec3( 0.0, .3 + .1 * abs(cos(attRandom.x * uniTime * 0.01)), 0.0 );\r\n  // La position est intrerpolée entre (x,y) et (xx,yy).\r\n  gl_Position = vec4( x * c2 + xx * c1, y * c2 + yy * c1, 0.0, 1.0 );\r\n  // Palpitation de la taille et diminution lors de la phase de désordre.\r\n  ang = t * attRandom.x;\r\n  gl_PointSize = max(8.0, (32.0 + 8.0 * cos(ang)) * (.5 + c2 * .5));\r\n}\r\n',fragment:"precision mediump float;\r\n\r\nvarying vec3 varColor;\r\nvarying float varCoeff;\r\n\r\nvoid main() {\r\n  // Calculons la distance du fragment courant\r\n  // au centre du point.\r\n  float x = gl_PointCoord.x - 0.5;\r\n  float y = gl_PointCoord.y - 0.5;\r\n  // On ne calcule pas la racine carré pour gagner du temps.\r\n  float r = x*x + y*y;\r\n  float alpha = clamp(1.0 - r * 4.0, 0.0, 1.0);\r\n\r\n  gl_FragColor = vec4( varColor, alpha * (1.0 - varCoeff * 0.3) );\r\n}\r\n"},u=r("dom"),c=r("tfw.data-binding"),m=function(r){var t=u.elem(this,"canvas");c.propInteger(this,"width")(function(r){t.setAttribute("width",r),t.style.width=r+"px"}),c.propInteger(this,"height")(function(r){t.setAttribute("height",r),t.style.height=r+"px"}),c.propBoolean(this,"zindex"),r=c.extend({width:640,height:480,zbuffer:!1},r,this);var n=new Image;n.src="css/wdg.gl7/tp.png",n.onload=e.bind(this,t,n)};t.exports=m,t.exports._=s});
>>>>>>> ed60770fef43ceb6207a072673d058559ad5436c
//# sourceMappingURL=wdg.gl7.js.map