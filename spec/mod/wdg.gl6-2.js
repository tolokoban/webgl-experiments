require("wdg.gl6-2",function(e,n,t){function r(e){function n(e){window.requestAnimationFrame(n);var r,o,i,l,s=e/1766.781248,A=Math.cos(s),h=Math.sin(s),v=e/1979.998511,E=Math.cos(v),_=Math.sin(v),R=A,b=h,p=h*_,F=E,P=-A*_,T=-h*E,C=_,m=A*E;for(l=0;l<u;l++)r=d[3*l+0],o=d[3*l+1],i=d[3*l+2],c[6*l+0]=r*R+0*o+i*b,c[6*l+1]=r*p+o*F+i*P,c[6*l+2]=r*T+o*C+i*m;f.sort(function(e,n){return c[6*n+2]-c[6*e+2]}),t.bindBuffer(t.ARRAY_BUFFER,a),t.bufferData(t.ARRAY_BUFFER,c,t.STATIC_DRAW),t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,g),t.bufferData(t.ELEMENT_ARRAY_BUFFER,f,t.STATIC_DRAW),t.clear(t.COLOR_BUFFER_BIT|t.DEPTH_BUFFER_BIT),t.drawElements(t.POINTS,u,t.UNSIGNED_SHORT,0)}var t=e.getContext("webgl")||e.getContext("experimental-webgl"),r=t.createProgram();t.attachShader(r,i(t,s.vertex)),t.attachShader(r,o(t,s.fragment)),t.linkProgram(r),t.useProgram(r);var a=t.createBuffer();t.bindBuffer(t.ARRAY_BUFFER,a);var u=56,c=new Float32Array(6*u);t.bufferData(t.ARRAY_BUFFER,c,t.STATIC_DRAW);var d=[],f=new Uint16Array(u),g=t.createBuffer();t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,g),t.bufferData(t.ELEMENT_ARRAY_BUFFER,f,t.STATIC_DRAW),function(){var e,n,t,r,a,o,i,s;for(n=0;n<u-6;n++)e=l(),c[6*n+3]=e.r,c[6*n+4]=e.g,c[6*n+5]=e.b,f[n]=n,i=.2*Math.PI+.6*n*Math.PI/(u-6-1),s=8.7*n*Math.PI/(u-6-1),a=Math.cos(i),o=Math.sin(i),t=o*Math.cos(s),r=o*Math.sin(s),d.push(t,r,a);for(n=u-6;n<u;n++)e=l(),f[n]=n,c[6*n+3]=e.r,c[6*n+4]=e.g,c[6*n+5]=e.b,d.push(0,0,2*(n-u+6)/5-1)}();var A=c.BYTES_PER_ELEMENT,h=6*A,v=t.getAttribLocation(r,"attPosition");t.enableVertexAttribArray(v),t.vertexAttribPointer(v,3,t.FLOAT,!1,h,0);var E=t.getAttribLocation(r,"attColor");t.enableVertexAttribArray(E),t.vertexAttribPointer(E,3,t.FLOAT,!1,h,3*A),Boolean(this.zbuffer)?(t.enable(t.DEPTH_TEST),t.depthFunc(t.LEQUAL),t.disable(t.BLEND),t.enable(t.BLEND),t.blendFunc(t.SRC_ALPHA,t.ONE_MINUS_SRC_ALPHA)):(t.enable(t.BLEND),t.blendFunc(t.SRC_ALPHA,t.ONE_MINUS_SRC_ALPHA),t.disable(t.DEPTH_TEST)),t.clearColor(0,0,0,1),t.bindBuffer(t.ARRAY_BUFFER,a),window.requestAnimationFrame(n)}function a(e,n,t){var r=n.createShader(e);return n.shaderSource(r,t),n.compileShader(r),n.getShaderParameter(r,n.COMPILE_STATUS)?r:(console.log(t),console.error("An error occurred compiling the shader: "+n.getShaderInfoLog(r)),null)}function o(e,n){return a(e.FRAGMENT_SHADER,e,n)}function i(e,n){return a(e.VERTEX_SHADER,e,n)}function l(){var e=Math.random(),n=Math.random(),t=Math.random();return e<n?t<e?(e=1,t=0):(e=1,n>t?t=0:n=0):n>t?(e=1,t=0):(n=0,e>t?e=1:t=1),{r:e,g:n,b:t}}var u=function(){function n(){return r(t,arguments)}var t={en:{}},r=e("$").intl;return n.all=t,n}(),s={vertex:"attribute vec3 attPosition;\nattribute vec3 attColor;\n\nvarying vec3 varPosition;\nvarying vec3 varColor;\n\nvoid main() {\n  float z = attPosition.z;\n  // Dans une projection 3D, les points éloignés de la caméra\n  // paraissent plus petits et plus proches les uns des autres.\n  // Cette variable permet de créer cet effet.\n  float depth = (1.5 - z) / 2.5;\n  gl_Position = vec4(attPosition.xy * depth, z, 1.0);\n\n  // La taille du point dépend aussi de la profondeur.\n  gl_PointSize = 80.0 * depth;\n  varPosition = attPosition;\n  varColor = attColor;\n}\n",fragment:"precision mediump float;\n\nvarying vec3 varPosition;\nvarying vec3 varColor;\n\nconst vec3 WHITE = vec3(1.0, 1.0, 1.0);\n\nvoid main() {\n  // Calculons la distance du fragment courant\n  // au centre du point.\n  float x = gl_PointCoord.x - 0.5;\n  float y = gl_PointCoord.y - 0.5;\n  // On ne calcule pas la racine carré pour gagner du temps.\n  float r = x*x + y*y;\n\n  x = gl_PointCoord.x;\n  y = gl_PointCoord.y;\n\n  // 0.25 = 0.5 * 0.5\n  if (r > 0.25) {\n    // Si on est à l'extérieur du cercle de rayon 0.5,\n    // on place un fragment transparent.\n    gl_FragColor = vec4( 0.0, 0.0, 0.0, 0.0 );\n  } else if (r > .2 ) {\n    // Au delà d'un certain rayon, on met une couleur fixe\n    // qui nous sert de liseré.\n    gl_FragColor = vec4(varColor, 1.0);\n  } else {\n    // Petit effet de dégradé.\n    vec3 col = x * varColor + y * WHITE;\n    gl_FragColor = vec4( col, 0.9 );\n  }\n  // La luminosité varie avec la profondeur du point.\n  // En `z = 0.0`, la boule est noire.\n  gl_FragColor = vec4( gl_FragColor.rgb * (1.0 - varPosition.z) / 2.0, gl_FragColor.a);\n}\n"},c=e("dom"),d=e("tfw.data-binding"),f=function(e){var n=c.elem(this,"canvas");d.propInteger(this,"width")(function(e){n.setAttribute("width",e),n.style.width=e+"px"}),d.propInteger(this,"height")(function(e){n.setAttribute("height",e),n.style.height=e+"px"}),d.propBoolean(this,"zindex"),e=d.extend({width:640,height:480,zbuffer:!1},e,this),window.setTimeout(r.bind(this,n),20)};n.exports=f,n.exports._=u});
//# sourceMappingURL=wdg.gl6-2.js.map