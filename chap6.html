<!DOCTYPE html><html><head><link href="https://fonts.googleapis.com/css?family=Josefin+Sans" rel="stylesheet" type="text/css"></link><title>webgl-experiments</title><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><script src="js/@chap6.js"></script><link rel="stylesheet" type="text/css" href="css/dom.css"><script src="js/$.js"></script><script src="js/wdg.gl6.js"></script><script src="js/tfw.data-binding.js"></script><script src="js/tfw.listeners.js"></script><script src="js/polyfill.string.js"></script><script src="js/dom.js"></script><script src="js/tfw.pointer-events.js"></script><script src="js/polyfill.classList.js"></script><script src="js/x-widget.js"></script><link rel="stylesheet" type="text/css" href="css/@chap6.css"></head><body class="theme-webgl theme-color-bg-B5"><section class="theme-color-bg-B0 theme-elevation-4"><h1 id="un-point-c-est-tout">Un point c&#39;est tout</h1>
<p>Dans les options de <code>gl.drawArrays()</code>, il y a une valeur qui semble à priori inutile : <strong><code>gl.POINTS</code></strong>. Ce chapitre va nous montrer qu&#39;on peut bien s&#39;amuser avec. Cet exemple utilise 6 vertices, par exemple :</p>
<div id="wdg.gl629" style="display:none"></div><p>Pour qu&#39;un point puisse être visualisé comme une sphère, on utilise deux variable du GLSL :</p>
<ul>
<li><strong>gl_PointSize</strong>: détermine la taille en pixel d&#39;un point (dansa le vertex shader). Par exemple <code>gl_PointSize = MIN_SIZE + (attPosition.z + 1.0) * (MAX_SIZE - MIN_SIZE) / 2.0;</code> permet de donner la taille MAX_SIZE aux points en <code>z = 1.0</code> et MIN_SIZE à ceux en <code>z = -1.0</code>.</li>
<li><strong>gl_PointCoord</strong>: vecteur à deux dimensions dont les valeurs des scalaires sont comprises entre 0 et 1. On peut comparer cela aux coordonnées UV utilisées pour les textures. Ainsi, (0,0) représente le coin supérieur gauche du point (qui est en fait un carré de côté <em>gl_PointSize</em>).</li>
</ul>
<p>Voici les shaders qui sont utilisés ici :</p>
<pre class="custom highlight js">
    attribute vec3 attPosition;
    attribute vec3 attColor;
    
    varying vec3 varPosition;
    varying vec3 varColor;
    <span class="keyword">
    void</span> <span class="function">main</span>() {
      float z <span class="operator">=</span> attPosition.z;
      <span class="comment">// Dans une projection 3D, les points éloignés de la caméra
    </span>  <span class="comment">// paraissent plus petits et plus proches les uns des autres.
    </span>  <span class="comment">// Cette variable permet de créer cet effet.
    </span>  float depth <span class="operator">=</span> (2.0 <span class="operator">-</span> z) <span class="operator">/</span> 3.0;
      gl_Position <span class="operator">=</span> <span class="function">vec4</span>(attPosition.xy <span class="operator">*</span> depth, z, 1.0);
    
      <span class="comment">// La taille du point dépend aussi de la profondeur.
    </span>  gl_PointSize <span class="operator">=</span> 150.0 <span class="operator">*</span> depth;
      varPosition <span class="operator">=</span> attPosition;
      varColor <span class="operator">=</span> attColor;
    }</pre><pre class="custom highlight js">
    precision mediump float;
    
    varying vec3 varPosition;
    varying vec3 varColor;
    <span class="keyword">
    const</span> vec3 WHITE <span class="operator">=</span> <span class="function">vec3</span>(1.0, 1.0, 1.0);
    <span class="keyword">
    void</span> <span class="function">main</span>() {
      <span class="comment">// Calculons la distance du fragment courant
    </span>  <span class="comment">// au centre du point.
    </span>  float x <span class="operator">=</span> gl_PointCoord.x <span class="operator">-</span> 0.5;
      float y <span class="operator">=</span> gl_PointCoord.y <span class="operator">-</span> 0.5;
      <span class="comment">// On ne calcule pas la racine carré pour gagner du temps.
    </span>  float r <span class="operator">=</span> x<span class="operator">*</span>x <span class="operator">+</span> y<span class="operator">*</span>y;
    
      x <span class="operator">=</span> gl_PointCoord.x;
      y <span class="operator">=</span> gl_PointCoord.y;
    
      <span class="comment">// 0.25 = 0.5 * 0.5
    </span> <span class="keyword"> if</span> (r <span class="operator">&gt;</span> 0.25) {
        <span class="comment">// Si on est à l'extérieur du cercle de rayon 0.5,
    </span>    <span class="comment">// on place un fragment transparent.
    </span>    gl_FragColor <span class="operator">=</span> <span class="function">vec4</span>( 0.0, 0.0, 0.0, 0.0 );
      }<span class="keyword"> else</span><span class="keyword"> if</span> (r <span class="operator">&gt;</span> .2 ) {
        <span class="comment">// Au delà d'un certain rayon, on met une couleur fixe
    </span>    <span class="comment">// qui nous sert de liseré.
    </span>    gl_FragColor <span class="operator">=</span> <span class="function">vec4</span>(varColor, 1.0);
      }<span class="keyword"> else</span> {
        <span class="comment">// Petit effet de dégradé.
    </span>    vec3 col <span class="operator">=</span> x <span class="operator">*</span> varColor <span class="operator">+</span> y <span class="operator">*</span> WHITE;
        gl_FragColor <span class="operator">=</span> <span class="function">vec4</span>( col, 1.0 );
      }
      <span class="comment">// La luminosité varie avec la profondeur du point.
    </span>  <span class="comment">// En `z = 0.0`, la boule est noire.
    </span>  gl_FragColor <span class="operator">=</span> <span class="function">vec4</span>( gl_FragColor.rgb <span class="operator">*</span> (1.0 <span class="operator">-</span> varPosition.z) <span class="operator">/</span> 2.0, gl_FragColor.a);
    }</pre><p>Il reste cependant un problème de taille : les balles qui sont à l&#39;arrière passent parfois devant celles de devant, ruinant ainsi le bel effet 3D auquel on s&#39;attendait.</p>
<p>Cela est du au fait que nous avons demandé à WebGL de superposer les images sans tenir compte du Z-buffer (technique utilisée pour ne pas afficher un pixel si le précedent à un <code>z</code> plus grand). Car voici ce qui se passe avec le Z-buffer activé :</p>
<div id="wdg.gl630" style="display:none"></div><p>Ce <strong>carré noir</strong> qui apparaît autour de nos sphères est du au fonctionnement du Z-buffer. En effet, à chaque fois que WebGL veut afficher un pixel, il commence par regarder sa coordonnée <code>z</code>. Dans un buffer (justement nommé Z-buffer) il garde la position <code>z</code> de chaque pixel de l&#39;écran. Cela lui sert à comparer avec le nouveau pixel. Si ce dernier a un <code>z</code> inférieur à celui trouvé dans le buffer pour la même position, alors <strong>le fragment shader n&#39;est même pas appelé</strong>.</p>
<p>Si vous regardez de plus près, vous vous dite : &quot;Hé ! Mais ça fonctionne pour certaines boules et pas pour les autres !!&quot;.</p>
<p>C&#39;est parce que ça dépend de l&#39;ordre d&#39;affichage des sphères. Si vous affichez une sphère de premier plan avant les autres, elle va placer son <code>z</code> dans le Z-buffer pour tous les pixels de son carré. Les pixels transparents ont le même <code>z</code> que les autres donc rien ne pourra être dessiné derrière eux, après eux. Mais s&#39;il y avait déjà quelque chose à l&#39;écran, alors on le verrait par transparence.</p>
<p>Une solution serait de donner à chaque pixel transparent un <code>z</code> très petit différent de celui du vertex.
Malheureusement, il est impossible de modifier le <code>z</code> dans un fragment shader.</p>
<p>Il ne nous reste qu&#39;une chose à faire : ne plus utiliser le Z-buffer et <strong>trier nous-même les sphères</strong> avant affichage.</p>
<hr/><ul>
<li>Chapitre précédent : <a href="chap5.html">Textures bitmaps</a>.</li>
<li>Page suivante : <a href="chap6-2.html">Un point c&#39;est tout (page 2)</a>.</li>
</ul>
</section><nav class="theme-color-bg-B2 theme-elevation-2"><p> Sommaire :</p>
<ul>
<li><a href="index.html">Comprendre WebGL</a></li>
<li><a href="chap1.html">Changer le système de coordonnées 2D</a></li>
<li><a href="chap2.html">Vivent les polygones</a></li>
<li><a href="chap3.html">Textures procédurales</a></li>
<li><a href="chap4.html">Animations</a></li>
<li><a href="chap5.html">Textures bitmaps</a></li>
<li><a href="chap6.html">Un point c&#39;est tout</a></li>
</ul>

</nav></body></html>