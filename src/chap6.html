<page>
   
# Un point c'est tout

Dans les options de `gl.drawArrays()`, il y a une valeur qui semble à priori inutile : __`gl.POINTS`__. Ce chapitre va nous montrer qu'on peut bien s'amuser avec. Cet exemple utilise 6 vertices, par exemple :

<wdg:gl6 $width="480" $height="480" />

Pour qu'un point puisse être visualisé comme une sphère, on utilise deux variable du GLSL :
* __gl_PointSize__: détermine la taille en pixel d'un point (dansa le vertex shader). Par exemple `gl_PointSize = MIN_SIZE + (attPosition.z + 1.0) * (MAX_SIZE - MIN_SIZE) / 2.0;` permet de donner la taille MAX_SIZE aux points en `z = 1.0` et MIN_SIZE à ceux en `z = -1.0`.
* __gl_PointCoord__: vecteur à deux dimensions dont les valeurs des scalaires sont comprises entre 0 et 1. On peut comparer cela aux coordonnées UV utilisées pour les textures. Ainsi, (0,0) représente le coin supérieur gauche du point (qui est en fait un carré de côté _gl_PointSize_).

Voici les shaders qui sont utilisés ici :

<x-code src="mod/gl6.vertex-a.c" />

<x-code src="mod/gl6.fragment-a.c" />


Il reste cependant un problème de taille : les balles qui sont à l'arrière passent parfois devant celles de devant, ruinant ainsi le bel effet 3D auquel on s'attendait.

Cela est du au fait que nous avons demandé à WebGL de superposer les images sans tenir compte du Z-buffer (technique utilisée pour ne pas afficher un pixel si le précedent à un `z` plus grand). Car voici ce qui se passe avec le Z-buffer activé :

<wdg:gl6 $width="480" $height="480" $zbuffer="true"/>

Ce __carré noir__ qui apparaît autour de nos sphères est du au fonctionnement du Z-buffer. En effet, à chaque fois que WebGL veut afficher un pixel, il commence par regarder sa coordonnée `z`. Dans un buffer (justement nommé Z-buffer) il garde la position `z` de chaque pixel de l'écran. Cela lui sert à comparer avec le nouveau pixel. Si ce dernier a un `z` inférieur à celui trouvé dans le buffer pour la même position, alors __le fragment shader n'est même pas appelé__.

Si vous regardez de plus près, vous vous dite : "Hé ! Mais ça fonctionne pour certaines boules et pas pour les autres !!".

C'est parce que ça dépend de l'ordre d'affichage des sphères. Si vous affichez une sphère de premier plan avant les autres, elle va placer son `z` dans le Z-buffer pour tous les pixels de son carré. Les pixels transparents ont le même `z` que les autres donc rien ne pourra être dessiné derrière eux, après eux. Mais s'il y avait déjà quelque chose à l'écran, alors on le verrait par transparence.

Une solution serait de donner à chaque pixel transparent un `z` très petit différent de celui du vertex.
Malheureusement, il est impossible de modifier le `z` dans un fragment shader.

Il ne nous reste qu'une chose à faire : ne plus utiliser le Z-buffer et __trier nous-même les sphères__ avant affichage.



<hr/>


* Chapitre précédent : [Textures bitmaps](chap5.html).
* Page suivante : [Un point c'est tout (page 2)](chap6-2.html).


</page>
