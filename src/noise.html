<page $title="Faites du bruit !">

Pour donner un peu de réalisme à nos textures, on peut y introduire du hasard.
L'approche la plus simple serait de créer une image préremplie en Javascript avec des valeurs aléatoires en guise de rouge, vert, bleu et opacité.

Malheureusement, ce hasard là est bien trop "dur" pour paraître naturel.  
Pourquoi ? Parce que __dans la nature, rien n'est indépendant de son environnement__.

C'est <a href="https://fr.wikipedia.org/wiki/Bruit_de_Perlin">Ken Perlin</a> qui, dans les années 80, a le premier compris cela.

Son idée est de créer une grille avec des vecteurs aléatoires sur chacune des intersections.
Pour calculer la valeur associée à un pixel, il faut d'abord trouver dans quelle cellule de la grille il se trouve.
Ensuite, on interpole les vecteurs aléatoires des 4 coins de cette cellule.

<x-widget name="noise.graph1" class="right" />

Voici comment on calcule la valeur du point `F` dans le schema ci-contre :
* Les flèches oranges sont les vecteurs unitaires aléatoires associés aux intersections de la grille.
* Le point `F` se trouve dans la cellule bleu foncé de côté unitaire (`AB=BC=CD=DA=1`).
* On calcule la valeur `Va` qui est le produit scalaire du vecteur orange en `A` et du vecteur `AF`.
* On fait le même calcul pour `Vb`, `Vc` et `Vd`.
* Ensuite on calcule `Vab` par interpolation entre `Va` et `Vb` (voir ci-dessous) et `Vcd` par interpolation entre `Vc` et `Vd`.
* Pour terminer, on interpole `Vab` et `Vcd` e on obtient une valeur pour le point `F`.

## L'interpolation

<x-widget name="noise.quads" class="right" />

Supposons que le point `A` ait pour coordonnées `(0,0)` et le point `C` `(1,1)`. Posons `F(x,y)`. Une interpolation linéaire (la plus simple) serait celle-ci :  
`Vab = (1 - y).Va + y.Vb`



# Maillage équilatéral
    
<x-widget name="noise.equilaterals" class="right" />

Pour passer d'un pavage à base de carrés à un pavages fait de triangles équilatéraux, il suffit de compresser la grille selon sa diagonale.
L'animation ci-contre illustre ce principe.

Mais comment fait-on pour compresser selon une diagonale ?

On sait qu'en utilisant une matrice, on est cabable de compresser selon l'axe des `x` de cette façon :
<wdg:matrix $value="[α,0 ; 0,1]*[x;y]"/>

On sait aussi faire une rotation d'angle φ avec cette matrice :
<wdg:matrix $value="[cos φ,-sin φ ; sin φ,cos φ]*[x;y]"/>

Il suffit donc de combiner une rotation de 45°, puis une compression sur l'axe des `x` et enfin une rotation de -45°. Et comme `cos 45° = sin 45° = √2 / 2`, `cos -45° = cos 45°` et `sin -45° = -sin 45°`, alors tout se simplifie et on obtient la matrice suivante :
<wdg:matrix $value="[√2 / 2,√2 / 2 ; √2 / 2,√2 / 2]*[α,0 ; 0,1]*[√2 / 2,√2 / 2;-√2 / 2,√2 / 2]=[α+1,α-1;α-1,α+1]/2"/>

</page>
