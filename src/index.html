<page>
<iframe class="left" width="240" height="240"
            src="css/assets/simple-triangle/index.html"></iframe>
  

__WebGL__ est une bibliothèque qui permet de faire de l' __Open GL__ sur le web.
Et __Open GL__ est une bibliothèque qui permet d'afficher des pixels à l'écran en tirant profit de l'_architecture parallèle_ des cartes graphiques.

__Open GL__ est à la fois __puissante__ et __complexe__.

Pour bien comprendre comment on utilise WebGL, nous allons étudier l'exemple
d'un triangle multicolore en rotation lente.

# La base

Basiquement, WebGL est capable de dessiner des triangles, des lignes, des points
et ... c'est tout !
Tout réside en fait dans la façon dont il dessine ces trois formes de base et
comment il combine les nouveaux pixels avec ceux déjà affichés.


Pour mieux comprendre comment ça marche, il faut mettre les mains dans le cambouis. Le code du triangle est [téléchargeable](css/assets/simple-triangle.zip) et je vous invite à jouer avec.

Pour fonctionner, votre `script.js` doit exécuter la fonction `start` avec deux arguments :
* une liste de fichiers à télécharger et
* la fonction à exécuter quand tous les téléchargements sont terminés.

Ça ressemble à ceci :
<x-code>
start( ["shader.vert", "shader.frag"], function( assets, canvas ) {
  ...
});
</x-code>

Dans l'exemple du triangle, l'objet `assets` ressemblera à ça :
<x-code>
{
  "shader.vert": "precision mediump float;\n\nvarying vec3 varColor;\n\nvoid main() { ...",
  "shader.frag": "uniform float uniTime;\n\nattribute vec3 attColor;\nattribute ..."
}    
</x-code>


## Le contexte

Le WebGL s'affiche dans un élément HTML particulier : le [canvas](https://developer.mozilla.org/fr/docs/Web/HTML/Element/canvas). Mais il est possible de faire beaucoup de choses dans un canvas, alors il faut qu'on précise ce que l'on veut en demandant un contexte WebGL.

<x-code src="mod/wdg.gl0.js" section="init" />

La variable `gl` possède désormais une instance de la classe `[WebGLRenderingContext](https://developer.mozilla.org/fr/docs/Web/API/WebGLRenderingContext)` qui permet d'accéder à toute l'API WebGL.


## Le vertex

WebGL dessine dans un espace à deux dimensions (notre canvas) dont le centre a pour coordonnées (0,0), le coin supérieur droit (1,1) et le coin inférieur droit (-1,-1). Il lui faut donc les coordonnées (X,Y) de trois points pour dessiner un triangle.

Vous pourriez penser que WebGL fournit une fonction du genre `drawTriangle( x1,y1, x2,y2, x3,y3 )`. C'est en effet assez fréquent dans la plupart des API graphiques 2D. Mais pour que le WebGL puisse exploiter pleinement la puissance des unités parallèles de calcul de la carte graphique, il nous faut prendre des chemins détournés.

Ainsi, au lieu de donner les coordonnées d'un point, on va donner les __attributs__ d'un __vertex__.
Ensuite, un programme écrit en langage [GLSL](https://fr.wikipedia.org/wiki/OpenGL_Shading_Language) va utiliser ces attributs (et peut-être d'autres variables) pour déterminer les coordonnées du point.

<img class="right thm-ele-2" src="css/gfx/index.triangle.jpeg"/>

Pour notre triangle, nous avons décidé de façon totalement arbitraire qu'un vertex serait défini par un angle.
Les points de notre triangle seront donc sur un cercle de rayon 1 et on déterminera leurs positions par un angle par rapport à l'horizontale comme le dessin ci-contre tente de l'illustrer.

Il nous faut donc un programme qui traduise ceci en coordonnées :
<x-code src="mod/assets/simple-triangle/shader-0.vert" />

La syntaxe est barbare, mais le code est plutôt simple.

On commence par déclarer notre attribut et son type. En GLSL, il faut toujours déclarer le type des variables. Ici, on a un `float` qui est un nombre à virgules.

Ensuite, on a la fonction `main()` qui sera appelée pour chaque vertex dont la carte graphique veut déterminer les coordonnées. Ce qui est intéressant ici, c'est plusieurs vertex peuvent être traités en même temps par des processeur parallèles. Et c'est en exploitant ceci que l'oon va atteindre de grande vitesses d'affichage.

Le calcul qui suit est simple : on traduit l'angle en radians et on utilise le cosinus et le sinus de cet angle pour déterminer les coordonnées.

La dernière ligne est particulière parce qu'elle ne ressemble pas à ce qu'on trouverait dans les langages de programmation courants. Ici, on ne retourne pas de valeur, mais on écrit le résultat dans une variable globale : `gl_Position`.

Cete variable est un vecteur à 4 dimensions : __X__, __Y__, __Z__ et __W__. Nous reviendrons plus tard sur __Z__ et __W__.


## Le fragment




----

----

Pour afficher notre triangle, on appelle la fonction suivante :

<x-code>gl.drawArrays( gl.TRIANGLES, 0, 3 );</x-code>

[`drawArrays()`](https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/drawArrays)
actionne le dessin par la carte graphique de plusieurs triangles (__TRIANGLES__).
Pour cela, il va lire __3__ points dans un tableau en commençant par l'index __0__.

Si j'avais passé __6__ comme dernier argument, la carte graphique aurait dessiné 2
triangles (à condition que mon tableau possède bien au moins 6 points).

# Les coordonnées d'un point

WebGL passe par deux phases pour dessiner ses triangles :
* déterminer les coordonnées des points (__vertex__ en anglais),
* déterminer la couleur des pixels du triangle défini par ces points (__segment__ en anglais).

Contrairement à ce qu'on pourrait imaginer, le tableau de points dont on parlait
plus haut ne donne pas directement les coordonnées des points.
Chaque point est en fait défini par un nombre quelconque de ce qu'on appèle
des __attributs__. Les attributs peuvent être des nombres, des vecteurs, des
matrices ou des tableaux de nombres/vecteurs/matrices.

Pour notre exemple, nous avons défini ces attributs-ci :
<x-code src="mod/wdg.gl0.js" section="attributes" />


Les attributs n'ont aucune signification pour WebGL. Il va juste les passer
à une fonction qui lui retournera les coordonnées finales.

ici, nous définissons 4 attributs pour chacun de nos 3 points :
* _attAngle_ : un angle en degrés sur un cercle.
* _attColor.r_ : le pourcentage de rouge dans la couleur finale du point.
* _attColor.g_ : le pourcentage de vert dans la couleur finale du point.
* _attColor.b_ : le pourcentage de bleu dans la couleur finale du point.

La fonction qui utilise ces attributs pour retourner les coordonnées du point
s'appelle un __vertex shader__.

<ex label="Voici le code de notre vertex shader" src="mod/gl0.vertex.c" lang="glsl"/>

Nous reviendrons sur les détails plus tard (notemment en ce qui concerne les lignes
`uniform float uniTime;` et `varying vec3 varColor;`).
Concentrons-nous pour l'instant sur les _attributs_ et sur les coordonnées du point.

Le __vertex shader__ est un programme écrit en 
[GLSL](https://www.khronos.org/files/opengles_shading_language.pdf),
un langage proche du C qui est compilé dans la carte graphique et utilisé
en parallèle sur le plus de points possibles.
Les cartes graphiques en 2017 ont plusieurs centaines de coeurs, ce qui signifie
qu'elles peuvent exécuter plusieurs centaines de coordonnées de points simultanément.

La fonction exécutée pour chaque point est __`void main()`__.
Curieusement, __elle n'a aucun argument et ne retourne rien__.
Elle utilise les attributs comme entrées et met à jour la variable globale
__gl_Position__ pour indiquer les coordonnées du point en sortie.

Comme on le voit, il s'agit d'un vecteur à 4 dimensions : X, Y, Z et W.
* __X__ et __Y__ donnent la position dans le canvas. Ce sont des nombres réels compris
entre -1 et +1. Ainsi, (0,0) est le centre de l'image.
* __Z__ est un réel compris entre -1 et +1. Il ne change rien à la position de nos points
qui doivent s'afficher sur un canvas en 2D. Mais nous verrons plus tars à quoi
cela peut être utile.
* __W__ est un facteur de distance : les coordonnées X et Y sont toujours divisées par W par WebGL.
On va donc le laisser à __1__ pour le moment.

Il faut noter que X et Y sont __toujours__ compris entre -1 et +1.
La forme du canvas n'y change rien.
C'est pourquoi le même code dans un canvas non carré donnera un résultat assez différent :

<wdg:gl0 $width="800" $height="100" />

# Comment faire le lien entre le tableau de nombres et les attibuts du vertex shader ?

Les commentaires n'étant visibles que par le codeur, voici comment WebGL voit notre
tableau d'attributs : `[0,1,0,0,130,0,1,0,200,0,0,1]`.
Il faut donc lui expliquer comment il va attribuer ces valeurs à ses attributs :
`float attAngle` et `vec3 attColor`.

Voici le code Javascript qui réalise ce mapping :
<x-code src="mod/wdg.gl0.js" section="vertex-position" />

Nous reviendrons plus tard sur la variable `program`.

* La fonction [`getAttribLocation(prg,name)`](https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/getAttribLocation)
retourne un pointeur sur l'attribut dont on passe le nom.
* La fonction [`enableVertexAttribArray(att)`](https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/enableVertexAttribArray)
active l'attribut qui pourra donc recevoir des données.
* La fonction [`vertexAttribPointer(att,size,type,normalized,stride,offset)`](https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/vertexAttribPointer)
définit précisément comment on associe les données du tableau à l'attribut.

Détaillons un peu les arguments de cette dernière fonction :
* __index__ : Le pointeur sur l'attribut concerné.
* __size__ : Le nombre d'éléments à utiliser dans le tableau pour renseigner cet attribut.
* __type__ : Le type des éléments du tableau à utiliser.
* __normalized__ : Permet de transformer des entiers en réels entre 0 et 1 (ou -1 et +1).
Aucun effet sur les `gl.FLOAT`.
* __stride__ : De combien d'__octets__ faut-il avancer pour trouver
les prochaines valeur pour le même attribut du point suivant.
La valeur maximale est 255.
* __offset__ : Décalage en __octets__ par rapport au début du tableau.

# Définir la couleur des pixels

Quand tous les points ont des coordonnées, WebGL peut déterminer quels sont les
pixels à mettre à jour.
Pour connaitre la couleur d'un pixel ou pour savoir s'il faut ne pas le dessiner,
il va faire appel à une autre code GLSL : le __fragment shader__.

<ex label="Voici le code de notre fragment shader" src="mod/gl0.fragment.c" lang="glsl"/>

Il est très similaire au vertex shader. Il varie surtout par ses entrées/sorties.

Premièrement pour la sortie, on utilise la vaiable globale __gl_FragColor__ qui
détermine une couleur à l'aide de ses quatre composantes (tous des réels entre 0 et 1) :
* __rouge__.
* __vert__.
* __bleu__.
* __opacité__ : 0 signifiant totalement transparent.

Ensuite, les attributs ne sont pas accessibles dans un fragment shader.
Il utilise des __varying__ qui sont des interpolations de valeurs définies
par chaque vertex environnant (3 pour les triangles, 2 pour les lignes, ...).

Le vertex shader a défini un __varying__ avec la valeur de son attribut __attColor__.
<x-code>varColor = attColor;</x-code>

Et comme il a le même nom dans le fragment shader, il est transmis et interpolé.

C'est cette interpolation qui produit le dégradé de couleurs que l'on voit dans
notre animation.

# Transmettre les données à la carte graphique

Si WebGL est si rapide à afficher des pixels, c'est parce qu'il fait travailler
la carte graphique au maximmum et laisse se reposer le processeur.
C'est aussi pour cela que tout paraît si compliqué.
Pour pouvoir faire un dessin, il faut que toutes les données soient présentent
dans la carte graphique au moment de l'appel à `drawArrays()`.

Voici comment on passe les données nécessaires à nos attributs :
<x-code src="mod/wdg.gl0.js" section="vertices" />
Pour plus de détails :
* [createBuffer()](https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/createBuffer)
* [bindBuffer()](https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/bindBuffer)
* [bufferData()](https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/bufferData)

Enfin, il faut aussi transmettre et compiler les GLSL des vertex et fragment shaders.
Pour cela, on les regroupe dans un __programme__ comme ceci :
<x-code src="mod/wdg.gl0.js" section="shaders" />

<ex label="Fonctions utilitaires" src="mod/wdg.gl0.js" section="shader"/>


# L'animation

Pour faire une animation, il suffit de redessiner la même scène en faisant varier
certains paramètres d'une image à l'autre.
Le plus simple est d'utiliser le temps. Ce genre de paramètre peut être passé
à un shader en utilisant un __uniform__. C'est un paramètre qui est constant
pour tous les vertex et fragments d'un affichage.

La fonction [`uniform1f(pos,val)`](https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/uniform)
permet de définir la valeur de l'uniform.

<x-code src="mod/wdg.gl0.js" section="rendering" />

# Conclusion

Il est important de bien comprendre ce chapitre avant de passer à la suite.

<ex label="Le code complet dans l'ordre" src="mod/wdg.gl0.js" section="code"/>
<ex label="Fonctions utilitaires" src="mod/wdg.gl0.js" section="shader"/>

Pour en être sûr, faites des exercices.
Par exemple, essayez de partir de rien et d'écrire le code qui permet de dessiner
une petite maison bleu avec un toît rouge (en fait, juste un carré bleu surmonté 
d'un triangle rouge). Bonne chance !



</page>
