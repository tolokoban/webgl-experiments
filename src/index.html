<page>
<div style="float:left; padding:.5rem"><wdg:gl0 $width="240" $height="240" /></div>
  

__WebGL__ est une bibliothèque qui permet de faire de l' __Open GL__ sur le web.
Et __Open GL__ est une bibliothèque qui permet d'afficher des pixels à l'écran en tirant profit de l'_architecture parallèle_ des cartes graphiques.

__Open GL__ est à la fois __puissante__ et __complexe__.

Pour bien comprendre comment on utilise WebGL, nous allons étudier l'exemple
d'un triangle multicolore en rotation lente.

# La base

Basiquement, WebGL est capable de dessiner des triangles, des lignes, des points
et ... c'est tout !
Tout réside en fait dans la façon dont il dessine ces trois formes de base et
comment il combine les nouveaux pixels avec ceux déjà affichés.

Le WebGL s'affiche dans un [canvas](https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API)
dont on récupère le contexte comme ceci :
<x-code src="mod/wdg.gl0.js" section="init" />

Pour afficher notre triangle, on appelle la fonction suivante :

<x-code>gl.drawArrays( gl.TRIANGLES, 0, 3 );</x-code>

[`drawArrays()`](https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/drawArrays)
actionne le dessin par la carte graphique de plusieurs triangles (__TRIANGLES__).
Pour cela, il va lire __3__ points dans un tableau en commençant par l'index __0__.

Si j'avais passé __6__ comme dernier argument, la carte graphique aurait dessiné 2
triangles (à condition que mon tableau possède bien au moins 6 points).

# Les coordonnées d'un point

WebGL passe par deux phases pour dessiner ses triangles :
* déterminer les coordonnées des points (__vertex__ en anglais),
* déterminer la couleur des pixels du triangle défini par ces points (__segment__ en anglais).

Contrairement à ce qu'on pourrait imaginer, le tableau de points dont on parlait
plus haut ne donne pas directement les coordonnées des points.
Chaque point est en fait défini par un nombre quelconque de ce qu'on appèle
des __attributs__. Les attributs peuvent être des nombres, des vecteurs, des
matrices ou des tableaux de nombres/vecteurs/matrices.

Pour notre exemple, nous avons défini ces attributs-ci :
<x-code src="mod/wdg.gl0.js" section="attributes" />

Les attributs n'ont aucune signification pour WebGL. Il va juste les passer
à une fonction qui lui retournera les coordonnées finales.

ici, nous définissons 4 attributs pour chacun de nos 3 points :
* _attAngle_ : un angle en degrés sur un cercle.
* _attColor.r_ : le pourcentage de rouge dans la couleur finale du point.
* _attColor.g_ : le pourcentage de vert dans la couleur finale du point.
* _attColor.b_ : le pourcentage de bleu dans la couleur finale du point.

La fonction qui utilise ces attributs pour retourner les coordonnées du point
s'appelle un __vertex shader__.

<wdg:showhide $value="false" $simple="true" $label="Voici le code de notre vertex shader.">
  <content>
    <x-code src="mod/gl0.vertex.c"/>
  </content>
</wdg:showhide>

Nous reviendrons sur les détails plus tard (notemment en ce qui concerne les lignes
`uniform float uniTime;` et `varying vec3 varColor;`).
Concentrons-nous pour l'instant sur les _attributs_ et sur les coordonnées du point.

Le __vertex shader__ est un programme écrit en [GLSL](https://www.khronos.org/files/opengles_shading_language.pdf),
un langage proche du C qui est compilé dans la carte graphique et utilisé
en parallèle sur le plus de points possibles.
Les cartes graphiques en 2017 ont plusieurs centaines de coeurs, ce qui signifie
qu'elles peuvent exécuter plusieurs centaines de coordonnées de points simultanément.

La fonction exécutée pour chaque point est __`void main()`__.
Curieusement, __elle n'a aucun argument et ne retourne rien__.
Elle utilise les attributs comme entrées et met à jour la variable globale
__gl_Position__ pour indiquer les coordonnées du point en sortie.

Comme on le voit, il s'agit d'un vecteur à 4 dimensions : X, Y, Z et W.
* __X__ et __Y__ donnent la position dans le canvas. Ce sont des nombres réels compris
entre -1 et +1. Ainsi, (0,0) est le centre de l'image.
* __Z__ est un réel compris entre 0 et +1. Il ne change rien à la position de nos points
qui doivent s'afficher sur un canvas en 2D. Mais nous verrons plus tars à quoi
cela peut être utile.
* __W__ est un facteur de distance : les coordonnées X et Y sont toujours divisées par W par WebGL.
On va donc le laisser à __1__ pour le moment.

Il faut noter que X et Y sont __toujours__ compris entre -1 et +1.
La forme du canvas n'y change rien.
C'est pourquoi le même code dans un canvas non carré donnera un résultat assez différent :

<wdg:gl0 $width="480" $height="120" />

# Comment faire le lien entre le tableau de nombres et les attibuts du vertex shader ?

Les commentaires n'étant visibles que par le codeur, voici comment WebGL voit notre
tableau d'attributs : `[0,1,0,0,130,0,1,0,200,0,0,1]`.
Il faut donc lui expliquer comment il va attribuer ces valeurs à ses attributs :
`float attAngle` et `vec3 attColor`.

Voici le code Javascript qui réalise ce mapping :
<x-code src="mod/wdg.gl0.js" section="vertex-position" />

Nous reviendrons plus tard sur la variable `program`.

* La fonction [`getAttribLocation(prg,name)`](https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/getAttribLocation)
retourne un pointeur sur l'attribut dont on passe le nom.
* La fonction [`enableVertexAttribArray(att)`](https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/enableVertexAttribArray)
active l'attribut qui pourra donc recevoir des données.
* La fonction [`vertexAttribPointer(att,size,type,normalized,stride,offset)`](https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/vertexAttribPointer)
définit précisément comment on associe les données du tableau à l'attribut.

Détaillons un peu les arguments de cette dernière fonction :
* __index__ : Le pointeur sur l'attribut concerné.
* __size__ : Le nombre d'éléments à utiliser dans le tableau pour renseigner cet attribut.
* __type__ : Le type des éléments du tableau à utiliser.
* __normalized__ : Permet de transformer des entiers en réels entre 0 et 1 (ou -1 et +1).
Aucun effet sur les `gl.FLOAT`.
* __stride__ : De combien d'__octets__ faut-il avancer pour trouver
les prochaines valeur pour le même attribut du point suivant.
La valeur maximale est 255.
* __offset__ : Décalage en __octets__ par rapport au début du tableau.

# Définir la couleur des pixels

Quand tous les points ont des coordonnées, WebGL peut déterminer quels sont les
pixels à mettre à jour.
Pour connaitre la couleur d'un pixel ou pour savoir s'il faut ne pas le dessiner,
il va faire appel à une autre code GLSL : le __fragment shader__.

<wdg:showhide $value="false" $simple="true" $label="Voici le code de notre fragment shader.">
  <content>
    <x-code src="mod/gl0.fragment.c"/>
  </content>
</wdg:showhide>

Il est très similaire au vertex shader. Il varie surtout par ses entrées/sorties.

Premièrement pour la sortie, on utilise la vaiable globale __gl_FragColor__ qui
détermine une couleur à l'aide de ses quatre composantes (tous des réels entre 0 et 1) :
* __rouge__.
* __vert__.
* __bleu__.
* __opacité__ : 0 signifiant totalement transparent.

Ensuite, les attributs ne sont pas accessibles dans un fragment shader.
Il utilise des __varying__ qui sont des interpolations de valeurs définies
par chaque vertex environnant (3 pour les triangles, 2 pour les lignes, ...).

Le vertex shader a défini un __varying__ avec la valeur de son attribut __attColor__.
<x-code>varColor = attColor;</x-code>

Et comme il a le même nom dans le fragment shader, il est transmis et interpolé.

C'est cette interpolation qui produit le dégradé de couleurs que l'on voit dans
notre animation.

# Transmettre les données à la carte graphique

Si WebGL est si rapide à afficher des pixels, c'est parce qu'il fait travailler
la carte graphique au maximmum et laisse se reposer le processeur.
C'est aussi pour cela que tout paraît si compliqué.
Pour pouvoir faire un dessin, il faut que toutes les données soient présentent
dans la carte graphique au moment de l'appel à `drawArrays()`.

Voici comment on passe les données nécessaires à nos attributs :
<x-code src="mod/wdg.gl0.js" section="vertices" />
Pour plus de détails :
* [createBuffer()](https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/createBuffer)
* [bindBuffer()](https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/bindBuffer)
* [bufferData()](https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/bufferData)

Enfin, il faut aussi transmettre et compiler les GLSL des vertex et fragment shaders.
Pour cela, on les regroupe dans un programme comme ceci :
<x-code src="mod/wdg.gl0.js" section="shaders" />

<wdg:showhide $value="false" $simple="true" $label="Fonctions utilitaires.">
  <content>
    <x-code src="mod/wdg.gl0.js" section="shader"/>
  </content>
</wdg:showhide>


# L'animation

Pour faire une animation, il suffit de redessiner la même scène en faisant varier
certains paramètres d'une image à l'autre.
Le plus simple est d'utiliser le temps. Ce genre de paramètre peut être passé
à un shader en utilisant un __uniform__. C'est un paramètre qui est constant
pour tous les vertex et fragments d'un affichage.

La fonction [`uniform1f(pos,val)`](https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/uniform)
permet de définir la valeur de l'uniform.

<x-code src="mod/wdg.gl0.js" section="rendering" />

# Conclusion

<wdg:showhide $value="false" $simple="true" $label="Le code complet dans l'ordre.">
  <content>
    <x-code src="mod/wdg.gl0.js" section="code"/>
  </content>
</wdg:showhide>

</page>
