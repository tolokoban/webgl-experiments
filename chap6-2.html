<!DOCTYPE html><html><head><link href="https://fonts.googleapis.com/css?family=Josefin+Sans" rel="stylesheet" type="text/css"></link><title>webgl-experiments</title><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><script src="js/@chap6-2.js"></script><link rel="stylesheet" type="text/css" href="css/dom.css"><script src="js/$.js"></script><script src="js/wdg.gl6-2.js"></script><script src="js/tfw.data-binding.js"></script><script src="js/tfw.listeners.js"></script><script src="js/polyfill.string.js"></script><script src="js/dom.js"></script><script src="js/tfw.pointer-events.js"></script><script src="js/polyfill.classList.js"></script><script src="js/x-widget.js"></script><link rel="stylesheet" type="text/css" href="css/@chap6-2.css"></head><body class="theme-webgl theme-color-bg-B5"><section class="theme-color-bg-B0 theme-elevation-4"><h1 id="un-point-c-est-tout">Un point c&#39;est tout</h1>
<div id="wdg.gl6-214" style="display:none"></div><p>Bien, il nous faut donc trier nos données de sorte à afficher les sphères les plus lointaines en premier.
Seulement ça semble un peu compliqué puisque nos données ont cette forme :</p>
<pre class="custom highlight js">
    [
      X1, Y1, Z1, Rouge1, Vert1, Bleu1,
      X2, Y2, Z2, Rouge2, Vert2, Bleu2,
      X3, Y3, Z3, Rouge3, Vert3, Bleu3,
      ...
    ]</pre><p>Il faudrait trier par blocs, ce qui est faisable, mais pas forcément très rapide, d&#39;autant plus qu&#39;on va devoir faire ça en Javascript.</p>
<p>Par chance, WebGL vient à la rescousse avec une fonction qu&#39;on n&#39;a pas encore étudiée : <strong><code>drawElements()</code></strong>.
Elle permet justement d&#39;indiquer l&#39;ordre dans lequel il faut prendre les vertices grace à un tableau d&#39;index qu&#39;on lui passe en argument. La solution est toute trouvée : c&#39;est ce tableau d&#39;index que l&#39;on va trier.</p>
<p>Comparons les fonctions <code>drawArrays</code> et <code>drawElements()</code>.</p>
<ul>
<li><strong>drawArrays(</strong> mode, first, count <strong>)</strong></li>
<li><strong>drawElements(</strong> mode, count, type, offset <strong>)</strong></li>
</ul>
<p>Et voici les arguments (dont certains sont communs) :</p>
<ul>
<li><strong>mode</strong> : gl.POINTS, gl.LINE_STRIP, gl.LINE_LOOP, gl.LINES, gl.TRIANGLE_STRIP, gl.TRIANGLE_FAN ou gl.TRIANGLES.</li>
<li><strong>first</strong> : index du premier vertex (généralement 0).</li>
<li><strong>count</strong> : nombre de vertex à afficher.</li>
<li><strong>type</strong> : gl.UNSIGNED_BYTE ou gl.UNSIGNED_SHORT. Si vous avez plus de 255 points, il vaut mieux spécifier gl.UNSIGNED_SHORT.</li>
<li><strong>offset</strong> : position du premier élément (généralement 0). Par rapport à l&#39;index du vertex, l&#39;offset doit être multiplié par <code>Uint16Array.BYTES_PER_ELEMENT</code>.</li>
</ul>
<p>Il va donc nous falloir passer deux buffers à la carte graphique : un <strong>Float32Array</strong> pour les attributs de chaque vertex et un <strong>Uint16Array</strong> pour les index sur ces vertices.</p>
<p>Voici comment on s&#39;y prend :</p>
<pre class="custom highlight js">
    var datAttributes <span class="operator">=</span><span class="keyword"> new</span> <span class="function">Float32Array</span>([ ... ]);<span class="keyword">
    var</span> bufAttributes <span class="operator">=</span> gl.<span class="function">createBuffer</span>();
    gl.<span class="function">bindBuffer</span>( gl.ARRAY_BUFFER, bufAttributes );
    gl.<span class="function">bufferData</span>( gl.ARRAY_BUFFER, datAttributes, gl.STATIC_DRAW );
        <span class="keyword">
    var</span> datIndexes <span class="operator">=</span><span class="keyword"> new</span> <span class="function">Uint16Array</span>([ 0, 1, 2, 3, ... ]);<span class="keyword">
    var</span> bufIndexes <span class="operator">=</span> gl.<span class="function">createBuffer</span>();
    gl.<span class="function">bindBuffer</span>( gl.ELEMENT_ARRAY_BUFFER, bufIndexes );
    gl.<span class="function">bufferData</span>( gl.ELEMENT_ARRAY_BUFFER, datIndexes, gl.STATIC_DRAW );</pre><p>Enfin, voici comment trier le tableau des index :</p>
<pre class="custom highlight js">
    datIndexes.<span class="function">sort</span><span class="keyword">(function</span>( i, j ) {
     <span class="keyword"> return</span> datAttributes[6 <span class="operator">*</span> j <span class="operator">+</span> 2] <span class="operator">-</span> datAttributes[6 <span class="operator">*</span> i <span class="operator">+</span> 2];
    });</pre><p>Quand on passe une fonction à la méthode <code>sort()</code>, celle-ci retourne un zéro si les deux valeurs en argument sont égales, un nombre positif si le premier argument est supérieur au second, ...</p>
<hr/><ul>
<li>Page précédente : <a href="chap6.html">Un point c&#39;est tout (page 1)</a>.</li>
</ul>
</section><nav class="theme-color-bg-B2 theme-elevation-2"><p> Sommaire :</p>
<ul>
<li><a href="index.html">Comprendre WebGL</a></li>
<li><a href="chap1.html">Changer le système de coordonnées 2D</a></li>
<li><a href="chap2.html">Vivent les polygones</a></li>
<li><a href="chap3.html">Textures procédurales</a></li>
<li><a href="chap4.html">Animations</a></li>
<li><a href="chap5.html">Textures bitmaps</a></li>
<li><a href="chap6.html">Un point c&#39;est tout</a></li>
</ul>

</nav></body></html>