<!DOCTYPE html><html><head><link href="https://fonts.googleapis.com/css?family=Josefin+Sans" rel="stylesheet" type="text/css"></link><title>webgl-experiments</title><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><script src="js/@chap4.js"></script><link rel="stylesheet" type="text/css" href="css/dom.css"><script src="js/$.js"></script><script src="js/wdg.gl4.js"></script><script src="js/tfw.data-binding.js"></script><script src="js/tfw.listeners.js"></script><script src="js/polyfill.string.js"></script><script src="js/dom.js"></script><script src="js/tfw.pointer-events.js"></script><script src="js/polyfill.classList.js"></script><script src="js/x-widget.js"></script><link rel="stylesheet" type="text/css" href="css/@chap4.css"></head><body class="theme-webgl theme-color-bg-B5"><section class="theme-color-bg-B0 theme-elevation-4"><style>
 article > * {
     display: inline-block;
     vertical-align: top;
 }
</style><h1 id="animations">Animations</h1>
<p>Jusqu&#39;à présent, nous avons créer des images statiques. Pour faire des animations, il suffit de créer de nombreuses images statiques, plusieurs fois par secondes. L&#39;idéal étant d&#39;atteindre les 60 images par seconde.</p>
<p>Pour cela, nous allons utiliser la fonction Javascript suivantes : <strong>window.requestAnimationFrame( drawingFunction )</strong>.</p>
<p>Cette dernière demande au système d&#39;exécuter la fonction <strong>drawingFunction()</strong> dès le prochain rafraichissement de l&#39;écran. Il faut noter deux choses : </p>
<ul>
<li><strong>drawingFunction()</strong> reçoit un argument unique qui correspond au nombre de millisecondes écoulées depuis le 1er janvier 1970.</li>
<li><strong>drawingFunction()</strong> n&#39;est appelée que si le canvas est visible à l&#39;écran.</li>
</ul>
<div id="wdg.gl412" style="display:none"></div><p>Voici le code complet de cette animation :</p>
<pre class="custom highlight js">
    var gl <span class="operator">=</span> canvas.<span class="function">getContext</span>(<span class="string">"webgl"</span>)
                <span class="operator">||</span> canvas.<span class="function">getContext</span>(<span class="string">"experimental-webgl"</span>);
    
       <span class="keyword"> var</span> shaderProgram <span class="operator">=</span> gl.<span class="function">createProgram</span>();
        gl.<span class="function">attachShader</span>( 
            shaderProgram, 
            <span class="function">getVertexShader</span>(gl, vertexShaderCode) );
        gl.<span class="function">attachShader</span>( 
            shaderProgram, 
            <span class="function">getFragmentShader</span>(gl, fragmentShaderCode) );
        gl.<span class="function">linkProgram</span>( shaderProgram );
        gl.<span class="function">useProgram</span>( shaderProgram );
    
       <span class="keyword"> var</span> squareVerticesBuffer <span class="operator">=</span> gl.<span class="function">createBuffer</span>();
        gl.<span class="function">bindBuffer</span>(gl.ARRAY_BUFFER, squareVerticesBuffer);
       <span class="keyword"> var</span> W <span class="operator">=</span> canvas.width;
       <span class="keyword"> var</span> H <span class="operator">=</span> canvas.height;
        gl.<span class="function">bufferData</span>(
            gl.ARRAY_BUFFER,
           <span class="keyword"> new</span> <span class="function">Float32Array</span>([
                0, 0, 0,
                W, 0, 0,
                0, H, 0,
                W, H, 0
            ]),
            gl.STATIC_DRAW
        );
        gl.<span class="function">bindBuffer</span>(gl.ARRAY_BUFFER, squareVerticesBuffer);
    
       <span class="keyword"> var</span> vertexPositionAttribute <span class="operator">=</span> gl.<span class="function">getAttribLocation</span>(shaderProgram, <span class="string">"attVertexPosition"</span>);
        gl.<span class="function">enableVertexAttribArray</span>(vertexPositionAttribute);
        gl.<span class="function">vertexAttribPointer</span>(vertexPositionAttribute, 3, gl.FLOAT, false, 0, 0);
    
        <span class="comment">// Déclaration de l'uniform `uniTime`.
    </span>   <span class="keyword"> var</span> uniTimeV <span class="operator">=</span> gl.<span class="function">getUniformLocation</span>(shaderProgram, <span class="string">"uniTimeV"</span>);
       <span class="keyword"> var</span> uniTimeF <span class="operator">=</span> gl.<span class="function">getUniformLocation</span>(shaderProgram, <span class="string">"uniTimeF"</span>);
    
       <span class="keyword"> var</span> uniWidth <span class="operator">=</span> gl.<span class="function">getUniformLocation</span>(shaderProgram, <span class="string">"uniWidth"</span>);
       <span class="keyword"> var</span> uniHeight <span class="operator">=</span> gl.<span class="function">getUniformLocation</span>(shaderProgram, <span class="string">"uniHeight"</span>);
    
       <span class="keyword"> function</span> <span class="function">draw</span>( t ) {
            <span class="comment">// Valeurs pour la taille de l'écran.
    </span>        gl.<span class="function">uniform1f</span>(uniWidth, canvas.width);
            gl.<span class="function">uniform1f</span>(uniHeight, canvas.height);
            <span class="comment">// Valeur de la variable uniforme pour le temps.
    </span>        gl.<span class="function">uniform1f</span>(uniTimeV, t);
            gl.<span class="function">uniform1f</span>(uniTimeF, t);
    
            gl.<span class="function">clearColor</span>(0.0, 0.0, 0.0, 0.0);
            gl.<span class="function">clear</span>(gl.COLOR_BUFFER_BIT <span class="operator">|</span> gl.DEPTH_BUFFER_BIT);
            gl.<span class="function">drawArrays</span>(gl.TRIANGLE_STRIP, 0, 4);
    
            <span class="comment">// Dessiner la prochaine frame.
    </span>       <span class="keyword2"> window</span>.<span class="function">requestAnimationFrame</span>( draw );
        }
    
       <span class="keyword2"> window</span>.<span class="function">requestAnimationFrame</span>( draw );</pre><p>Trois remarques importantes à ce stade :</p>
<ul>
<li>Les nombre litéraux de type <em>float</em> doivent toujours avoir une partie décimale. Par exemple, n&#39;écrivez pas <code>if (x &lt; 0)</code>, mais plutôt <code>if (x &lt; 0.0)</code>.</li>
<li>Il faut spécifier les valeurs des <em>uniforms</em> à chaque fois qu&#39;on dessine.</li>
<li>Il n&#39;est pas possible d&#39;utiliser le même <em>uniform</em> dans le vertex shader et le segment shader. C&#39;est pour cela qu&#39;on utilise <strong>uniTimeV</strong> et <strong>uniTimeS</strong>.</li>
</ul>
<p>Voici le code du <strong>vertex shader</strong> qui modifie les coordonnées de notre quadrilatère en fonction du temps :</p>
<pre class="custom highlight js">
    attribute vec3 attVertexPosition;
    
    uniform float uniWidth;
    uniform float uniHeight;
    
    uniform lowp float uniTimeV;
    
    varying lowp vec3 varVertexPosition;
    <span class="keyword">
    void</span> <span class="function">main</span>() {
      highp float time <span class="operator">=</span> uniTimeV;
    
      varVertexPosition <span class="operator">=</span> attVertexPosition;
      
      float x <span class="operator">=</span> attVertexPosition.x;
      float y <span class="operator">=</span> attVertexPosition.y;
    
      x <span class="operator">=</span> (2.0 <span class="operator">*</span> x <span class="operator">/</span> uniWidth) <span class="operator">-</span> 1.0;
      y <span class="operator">=</span> 1.0 <span class="operator">-</span> (2.0 <span class="operator">*</span> y <span class="operator">/</span> uniHeight);
    
      float speed <span class="operator">=</span> 0.0;
    
     <span class="keyword"> if</span> (x <span class="operator">&lt;</span> 0.0) {
       <span class="keyword"> if</span> (y <span class="operator">&lt;</span> 0.0) {
          speed <span class="operator">=</span> 1600.0;
        }<span class="keyword"> else</span> {
          speed <span class="operator">=</span> 1643.0;
        }
      }<span class="keyword"> else</span> {
       <span class="keyword"> if</span> (y <span class="operator">&lt;</span> 0.0) {
          speed <span class="operator">=</span> 1703.0;
        }<span class="keyword"> else</span> {
          speed <span class="operator">=</span> 1742.0;
        }
      }
    
      float radius <span class="operator">=</span> 0.5 <span class="operator">+</span> (<span class="function">cos</span>(time <span class="regexp">/ speed) + 1.0) /</span> 4.0;
      gl_Position <span class="operator">=</span> <span class="function">vec4</span>( x <span class="operator">*</span> radius, y <span class="operator">*</span> radius, 0.0, 1.0 );
    }</pre><p>Voici le code du <strong>fragment shader</strong> qui donne cet effet de vagues :</p>
<pre class="custom highlight js">
    const highp float PI <span class="operator">=</span> 3.1415926539;<span class="keyword">
    const</span> lowp vec3 COLOR0 <span class="operator">=</span> <span class="function">vec3</span>(0.7, 0.9, 1.0);<span class="keyword">
    const</span> lowp vec3 COLOR1 <span class="operator">=</span> <span class="function">vec3</span>(0.0, 0.7, 0.9);
    
    varying lowp vec3 varVertexPosition;
    
    uniform lowp float uniTimeF;
    <span class="keyword">
    void</span> <span class="function">main</span>() {
      highp float time <span class="operator">=</span> uniTimeF <span class="operator">/</span> 700.0;
      
      lowp float x <span class="operator">=</span> varVertexPosition.x <span class="operator">+</span> time <span class="operator">*</span> 120.0;
      lowp float y <span class="operator">=</span> varVertexPosition.y <span class="operator">+</span> <span class="function">sin</span>(time) <span class="operator">*</span> 15.0;
      
      lowp float xx <span class="operator">=</span> x <span class="operator">/</span> 10.0;
      lowp float yy <span class="operator">=</span> y <span class="operator">/</span> 10.0;
      
      lowp float h <span class="operator">=</span> <span class="function">cos</span>(yy) <span class="operator">*</span> <span class="function">cos</span>(xx) <span class="operator">+</span> <span class="function">sin</span>(yy);
      h <span class="operator">=</span> <span class="function">cos</span>( PI <span class="operator">*</span> h <span class="operator">+</span> time);
      
      h <span class="operator">=</span> (1.0 <span class="operator">+</span> h) <span class="operator">/</span> 2.0;
      gl_FragColor <span class="operator">=</span> <span class="function">vec4</span>( h <span class="operator">*</span> COLOR0 <span class="operator">+</span> (1.0 <span class="operator">-</span> h) <span class="operator">*</span> COLOR1, 1.0);
    }</pre><h2 id="faites-vos-essais">Faites vos essais</h2>
<p>La plupart du temps, la mise au point d&#39;un shader se fait de façon empirique. On change un paramètre et on regarde ce que ça donne. Mais cela peut être fastidieux. Heureusement, Firefox nous permet de modifier en temps réel le code d&#39;un shader et de voir le résultat sans recharger la page.</p>
<p>Pour cela, ouvrez la console de debug en appuyant sur <strong>F12</strong>.</p>
<ul>
<li>Parmi la foule d&#39;icônes que vous apercevez, cliquez sur l&#39;engrenage. </li>
<li>Dans la section <strong>Outils de dévelopement par défaut</strong>, sélectionnez l&#39;option <strong>Editeur de shaders</strong>.</li>
<li>Un nouvel onglet apparaît avec la liste des programmes de shading disponibles dans la page.</li>
</ul>
<p>Je vous conseille d&#39;essayer de modifier quelques paramètres du shader des vagues pour vous familiariser avec l&#39;outil et avec le GLSL (language des shaders).</p>
<hr/><ul>
<li>Chapitre précédent : </li>
</ul>
<a href="chap3.html">Textures procédurales</a><p>.</p>
<ul>
<li>Chapitre suivant : </li>
</ul>
<a href="chap5.html">Textures bitmaps</a><p>.</p>
</section><nav class="theme-color-bg-B2 theme-elevation-2"><p> Sommaire :</p>
<ul>
<li><a href="index.html">Comprendre WebGL</a></li>
<li><a href="chap1.html">Changer le système de coordonnées 2D</a></li>
<li><a href="chap2.html">Vivent les polygones</a></li>
<li><a href="chap3.html">Textures procédurales</a></li>
<li><a href="chap4.html">Animations</a></li>
<li><a href=""></a></li>
</ul>

</nav></body></html>