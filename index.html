<!DOCTYPE html><html><head><link href="https://fonts.googleapis.com/css?family=Josefin+Sans" rel="stylesheet" type="text/css"></link><title>webgl-experiments</title><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><script src="js/@index.js"></script><link rel="stylesheet" type="text/css" href="css/dom.css"><script src="js/$.js"></script><script src="js/wdg.gl0.js"></script><script src="js/tfw.data-binding.js"></script><script src="js/tfw.listeners.js"></script><script src="js/polyfill.string.js"></script><script src="js/dom.js"></script><script src="js/tfw.pointer-events.js"></script><script src="js/polyfill.classList.js"></script><script src="js/x-widget.js"></script><link rel="stylesheet" type="text/css" href="css/@index.css"></head><body class="theme-webgl theme-color-bg-B5"><section class="theme-color-bg-B0 theme-elevation-4"><h1 id="comprendre-webgl">Comprendre WebGL</h1>
<h2 id="introduction">Introduction</h2>
<p><strong>WebGL</strong> est une bibliothèque qui permet de faire de l&#39;<strong>Open GL</strong> sur le web. Et l&#39;<strong>Open GL</strong> est une bibliothèque qui permet d&#39;afficher des pixels à l&#39;écran en tirant profit de l&#39;<em>architecture parallèle</em> des cartes graphiques.</p>
<p><strong>Open GL</strong> est donc à la fois <strong>puissante</strong> et <strong>complexe</strong>.</p>
<p>Commençons par ce qui prendrait trois lignes avec un canvas 2d : le dessin d&#39;un triangle.</p>
<div id="wdg.gl012" style="display:none"></div><p>On commence par récupérer le contexte <em>webgl</em> d&#39;un canvas :</p>
<pre class="custom highlight js">
    var gl <span class="operator">=</span> canvas.<span class="function">getContext</span>(<span class="string">"webgl"</span>)
                <span class="operator">||</span> canvas.<span class="function">getContext</span>(<span class="string">"experimental-webgl"</span>);</pre><p>Ensuite, il faut créer un <strong>programme de shading</strong>.
Il s&#39;agit de code, ressemblant fort à du C, qui sera compilé dans la carte graphique et utilisé simultanément par ses nombreux processeurs pour mettre à jour les pixels.
Nous reviendrons un peu plus tard sur cela.</p>
<pre class="custom highlight js">
    var shaderProgram <span class="operator">=</span> gl.<span class="function">createProgram</span>();
        gl.<span class="function">attachShader</span>(shaderProgram, <span class="function">getVertexShader</span>(gl, GLOBAL['vertex']) );
        gl.<span class="function">attachShader</span>(shaderProgram, <span class="function">getFragmentShader</span>(gl, GLOBAL['fragment']) );
        gl.<span class="function">linkProgram</span>(shaderProgram);
        gl.<span class="function">useProgram</span>(shaderProgram);</pre><p>Nous allons maintenant définir les coordonnées des sommets (vertices) de notre triangle rectangle. Chaque coordonnée est exprimée en trois dimensions.</p>
<pre class="custom highlight js">
    var triangleVerticesBuffer <span class="operator">=</span> gl.<span class="function">createBuffer</span>();
        gl.<span class="function">bindBuffer</span>(gl.ARRAY_BUFFER, triangleVerticesBuffer);
        gl.<span class="function">bufferData</span>(
            gl.ARRAY_BUFFER,
           <span class="keyword"> new</span> <span class="function">Float32Array</span>([
                    <span class="operator">-</span>.8, <span class="operator">+</span>.8, .0,
                    <span class="operator">+</span>.8, <span class="operator">-</span>.8, .0,
                    <span class="operator">-</span>.8, <span class="operator">-</span>.8, .0
            ]),
            gl.STATIC_DRAW
        );
        gl.<span class="function">bindBuffer</span>(gl.ARRAY_BUFFER, triangleVerticesBuffer);</pre><p>Il faut ensuite déclarer un <strong>attribut</strong> qui sera utilisé par les shaders.
L&#39;attribut que nous créons sera nommé <code>attVertexPosition</code>.</p>
<pre class="custom highlight js">
    var vertexPositionAttribute <span class="operator">=</span> gl.<span class="function">getAttribLocation</span>(shaderProgram, <span class="string">"attVertexPosition"</span>);
        gl.<span class="function">enableVertexAttribArray</span>(vertexPositionAttribute);
        gl.<span class="function">vertexAttribPointer</span>(vertexPositionAttribute, 3, gl.FLOAT, false, 0, 0);</pre><p>Pour finir, on lance le rendu. D&#39;abord on définit la couleur de fond (un bleu tout simple). Puis on efface l&#39;écran et on dessine un triangle.</p>
<pre class="custom highlight js">
    gl.<span class="function">clearColor</span>(0.0, 0.0, 1.0, 1.0);
        gl.<span class="function">clear</span>(gl.COLOR_BUFFER_BIT <span class="operator">|</span> gl.DEPTH_BUFFER_BIT);
        gl.<span class="function">drawArrays</span>(gl.TRIANGLE_STRIP, 0, 3);</pre><p>Vous avez pratiquement tout le code pour faire la même chose. Il ne manque que les shaders qui ont été ici remplacés par <code>GLOBAL[&#39;vertex&#39;]</code> et <code>GLOBAL[&#39;fragment&#39;]</code>. Les voici :</p>
<pre class="custom highlight js">
    var GLOBAL <span class="operator">=</span> {
      vertex:
        <span class="string">"attribute vec3 attVertexPosition;"</span> <span class="operator">+</span>
        <span class="string">"void main() {"</span> <span class="operator">+</span>
        <span class="string">"  gl_Position = vec4("</span> <span class="operator">+</span>
        <span class="string">"      attVertexPosition.x, attVertexPosition.y,"</span> <span class="operator">+</span>
        <span class="string">"      0.0, 1.0);"</span>,
      fragment:
        <span class="string">"void main() {"</span> <span class="operator">+</span>
        <span class="string">"  gl_FragColor = vec4(1.0, 0.5, 0.0, 1.0);"</span> <span class="operator">+</span>
        <span class="string">"}"</span>
    };</pre><p>Pour plus de clarté, voici les codes originaux :</p>
<pre class="custom highlight js">
    attribute vec3 attVertexPosition;
    <span class="keyword">
    void</span> <span class="function">main</span>() {
      gl_Position <span class="operator">=</span> <span class="function">vec4</span>(
          attVertexPosition.x, attVertexPosition.y,
          0.0, 1.0);
    }</pre><pre class="custom highlight js">
    void <span class="function">main</span>() {
      gl_FragColor <span class="operator">=</span> <span class="function">vec4</span>(1.0, 0.5, 0.0, 1.0);
    }</pre><p>Basiquement, un shader est une fonction <code>void main()</code> qui doit mettre à jour des variables.</p>
<ul>
<li>Le <strong>vertex shader</strong> est appelé en premier pour chaque point (vertex). Il doit définir la variable <strong>gl_Position</strong> qui est un vecteur de dimension 4. Les deux premières coordonnées sont l&#39;abscisse et l&#39;ordonnée du pixel sur l&#39;écran. Mais attention ! Le système de coordonnée de l&#39;écran est particulier. Le point central est (0,0), le point supérieur droit est (+1,+1) et le point inférieur gauche est (-1,-1). Et ceci, quelque soit la taille réalle du canvas.</li>
<li>Le <strong>fragment shader</strong> vient après et il est appelé pour chaque pixel de l&#39;écran. Il doit définir la couleur de ce pixel en mettant à jour la variable <strong>gl_FragColor</strong> qui est un vecteur de dimension 4 : rouge, vert, bleu et opacité.</li>
</ul>
<hr/><ul>
<li>Chapitre suivant : </li>
</ul>
<a href="chap1.html">Changer le système de coordonnées 2D</a><p>.</p>
</section><nav class="theme-color-bg-B2 theme-elevation-2"><p> Sommaire :</p>
<ul>
<li><a href="index.html">Comprendre WebGL</a></li>
<li><a href="chap1.html">Changer le système de coordonnées 2D</a></li>
<li><a href="chap2.html">Vivent les polygones</a></li>
<li><a href="chap3.html">Textures procédurales</a></li>
<li><a href="chap4.html">Animations</a></li>
<li><a href=""></a></li>
</ul>

</nav></body></html>