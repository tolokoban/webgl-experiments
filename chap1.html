<!DOCTYPE html><html><head><link href="https://fonts.googleapis.com/css?family=Josefin+Sans" rel="stylesheet" type="text/css"></link><title>webgl-experiments</title><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><script src="js/@chap1.js"></script><link rel="stylesheet" type="text/css" href="css/dom.css"><script src="js/$.js"></script><script src="js/wdg.gl1.js"></script><script src="js/tfw.data-binding.js"></script><script src="js/tfw.listeners.js"></script><script src="js/polyfill.string.js"></script><script src="js/dom.js"></script><script src="js/tfw.pointer-events.js"></script><script src="js/polyfill.classList.js"></script><script src="js/x-widget.js"></script><link rel="stylesheet" type="text/css" href="css/@chap1.css"></head><body class="theme-webgl theme-color-bg-B5"><section class="theme-color-bg-B0 theme-elevation-4"><h1 id="changer-le-syst-me-de-coordonn-es-2d">Changer le système de coordonnées 2D</h1>
<p>Le principal problème du système de coordonnées en [-1 ; +1] est qu&#39;il ne respecte pas les carrés !
En effet, pour Open GL, la largeur de votre canvas est de 2 et sa hauteur aussi, même si ce dernier est un rectangle flagrant.</p>
<p>On ne peut pas changer cela. Mais on peut tricher pour que ce ne soit plus un problème. Nous allons dessiner un carré dont on spécifiera les coordonnées dans le système du canvas : le point supérieur gauche sera (0,0) et le point inférieur droit sera (W,H), où W est la larguer en pixel du canvas (H la hauteur).</p>
<p>On pourrait très bien réaliser ceci en créant une fonction de transformation des coordonnées avant de les passer à Open GL. Mais ce serait du Javascript, et ce serait donc très lent.
La meilleure solution consiste à faire faire le travail par le <em>vertex shader</em>. Et ça tombe bien, car il sert précisément à cela : modifier les coordonnées.</p>
<p>Mais pour que cela fonctionne, il faut que le shader connaisse la largeur et la hauteur de notre canvas. Il faut donc lui passer des variables. Puisque les valeurs de ces variables ne changent pas pendant le dessin d&#39;une image, on utilise des variables de type <strong>Uniform</strong>.</p>
<p>On ajoute donc ce code juste avant le rendu :</p>
<pre class="custom highlight js">
    var uniWidth <span class="operator">=</span> gl.<span class="function">getUniformLocation</span>(shaderProgram, <span class="string">"uniWidth"</span>);
       <span class="keyword"> var</span> uniHeight <span class="operator">=</span> gl.<span class="function">getUniformLocation</span>(shaderProgram, <span class="string">"uniHeight"</span>);</pre><p>Et il faut changer le code du <em>vertex shader</em> pour qu&#39;il utilise ces deux variables :</p>
<pre class="custom highlight js">
    attribute vec3 attVertexPosition;
    
    uniform float uniWidth;
    uniform float uniHeight;
    <span class="keyword">
    void</span> <span class="function">main</span>() {
      float x <span class="operator">=</span> attVertexPosition.x;
      float y <span class="operator">=</span> attVertexPosition.y;
    
      x <span class="operator">=</span> (2.0 <span class="operator">*</span> x <span class="operator">/</span> uniWidth) <span class="operator">-</span> 1.0;
      y <span class="operator">=</span> 1.0 <span class="operator">-</span> (2.0 <span class="operator">*</span> y <span class="operator">/</span> uniHeight);
    
      gl_Position <span class="operator">=</span> <span class="function">vec4</span>( x, y, 0.0, 1.0 );
    }</pre><p>On peut désormais utiliser de nouvelles coordonnées. On choisit un carré de larguer 100x100 positionné en (20,20) :</p>
<pre class="custom highlight js">
    var squareVerticesBuffer <span class="operator">=</span> gl.<span class="function">createBuffer</span>();
        gl.<span class="function">bindBuffer</span>(gl.ARRAY_BUFFER, squareVerticesBuffer);
        gl.<span class="function">bufferData</span>(
            gl.ARRAY_BUFFER,
           <span class="keyword"> new</span> <span class="function">Float32Array</span>([
                20, 20, 0,
                120, 20, 0,
                20, 120, 0,
                120, 120, 0
            ]),
            gl.STATIC_DRAW
        );</pre><p>Tada ! En voilà un beau carré :</p>
<<<<<<< HEAD
<div id="wdg.gl10" style="display:none"></div><p>Une minute ! Comment peut-on dessiner un carré avec la fonction suivante : <code>gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);</code> ? On y parle de <strong>TRIANGLE_STRIP</strong>, qu&#39;est-ce donc ?</p>
=======
<div id="wdg.gl118" style="display:none"></div><p>Une minute ! Comment peut-on dessiner un carré avec la fonction suivante : <code>gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);</code> ? On y parle de <strong>TRIANGLE_STRIP</strong>, qu&#39;est-ce donc ?</p>
>>>>>>> 509a8c8ca996e9d07bb19237057a74984fad9567
<p>En fait, le TRIANGLE_STRIP est une bande de triangles. Les 3 premiers points définissent un triangle, normal. Mais ensuite, chaque point ajouté définit un nouveau triangle. Ainsi, si on a les points [A, B, C, D, E], on dessinera 3 triangles : ABC, BDC, CDE.</p>
<p>Et ce n&#39;est pas la seule option, comme nous le verrons dans le chapitre suivant.</p>
<hr/><ul>
<li>Chapitre précédent : </li>
</ul>
<a href="index.html">Comprendre WebGL</a><p>.</p>
<ul>
<li>Chapitre suivant : </li>
</ul>
<a href="chap2.html">Vivent les polygones</a><p>.</p>
</section><nav class="theme-color-bg-B2 theme-elevation-2"><p> Sommaire :</p>
<ul>
<li><a href="index.html">Comprendre WebGL</a></li>
<li><a href="chap1.html">Changer le système de coordonnées 2D</a></li>
<li><a href="chap2.html">Vivent les polygones</a></li>
<li><a href="chap3.html">Textures procédurales</a></li>
<li><a href="chap4.html">Animations</a></li>
<li><a href="chap5.html">Textures bitmaps</a></li>
<li><a href="chap6.html">Un point c&#39;est tout</a></li>
</ul>

</nav></body></html>