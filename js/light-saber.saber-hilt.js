"use strict";function _slicedToArray(arr,i){return _arrayWithHoles(arr)||_iterableToArrayLimit(arr,i)||_nonIterableRest()}function _nonIterableRest(){throw new TypeError("Invalid attempt to destructure non-iterable instance")}function _iterableToArrayLimit(arr,i){var _arr=[],_n=!0,_d=!1,_e=void 0;try{for(var _s,_i=arr[Symbol.iterator]();!(_n=(_s=_i.next()).done)&&(_arr.push(_s.value),!(i&&_arr.length===i));_n=!0);}catch(err){_d=!0,_e=err}finally{try{_n||null==_i["return"]||_i["return"]()}finally{if(_d)throw _e}}return _arr}function _arrayWithHoles(arr){if(Array.isArray(arr))return arr}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")}function _defineProperties(target,props){for(var descriptor,i=0;i<props.length;i++)descriptor=props[i],descriptor.enumerable=descriptor.enumerable||!1,descriptor.configurable=!0,"value"in descriptor&&(descriptor.writable=!0),Object.defineProperty(target,descriptor.key,descriptor)}function _createClass(Constructor,protoProps,staticProps){return protoProps&&_defineProperties(Constructor.prototype,protoProps),staticProps&&_defineProperties(Constructor,staticProps),Constructor}require("light-saber.saber-hilt",function(require,module){function createMesh(){for(var attribs=6,sectors=12,angleStep=2*Math.PI/sectors,line=[[0,0],[.05,.02],[.02,0],[.03,-.1],[.03,-.15],[.02,-.25],[.03,-.26],[0,-.27]],arrayVert=[0,line[0][1],0,0,1,0],arrayElem=[],k=1;k<line.length-1;k++)for(var ring0=line[k-1],ring1=line[k],ring2=line[k+1],i=0;i<sectors;i++){var ang=angleStep*i,_ring=_slicedToArray(ring0,2),radius0=_ring[0],y0=_ring[1],x0=radius0*Math.cos(ang),z0=radius0*Math.sin(ang),_ring2=_slicedToArray(ring1,2),radius1=_ring2[0],y1=_ring2[1],x1=radius1*Math.cos(ang),z1=radius1*Math.sin(ang),_ring3=_slicedToArray(ring2,2),radius2=_ring3[0],y2=_ring3[1],x2=radius2*Math.cos(ang),z2=radius2*Math.sin(ang),_computeNormal=computeNormal(x0,y0,z0,x1,y1,z1,x2,y2,z2),_computeNormal2=_slicedToArray(_computeNormal,3),nx=_computeNormal2[0],ny=_computeNormal2[1],nz=_computeNormal2[2];arrayVert.push(x1,y1,z1,nx,ny,nz)}arrayVert.push(0,line[line.length-1][1],0,0,-1,0);for(var _i2=0;_i2<sectors;_i2++)arrayElem.push(_i2+1,0,(_i2+1)%sectors+1);for(var _k=0;_k<line.length-3;_k++)for(var idxRing0=1+sectors*_k,idxRing1=idxRing0+sectors,_i3=0;_i3<sectors;_i3++){var A=idxRing0+_i3,B=idxRing1+_i3,C=idxRing1+(_i3+1)%sectors,D=idxRing0+(_i3+1)%sectors;arrayElem.push(A,C,B),arrayElem.push(A,D,C)}for(var idxBottom=Math.floor(arrayVert.length/attribs)-1,idxRing=idxBottom-sectors,_i4=0;_i4<sectors;_i4++)arrayElem.push(idxBottom,idxRing+_i4,idxRing+(_i4+1)%sectors);return{arrayVert:new Float32Array(arrayVert),arrayElem:new Uint16Array(arrayElem)}}function computeNormal(x0,y0,z0,x1,y1,z1,x2,y2,z2){var vxA=x0-x1,vyA=y0-y1,vzA=z0-z1,invLenA=1/Math.sqrt(vxA*vxA+vyA*vyA+vzA*vzA),vxB=x2-x1,vyB=y2-y1,vzB=z2-z1,invLenB=1/Math.sqrt(vxB*vxB+vyB*vyB+vzB*vzB),vx=invLenA*vxA+invLenB*vxB,vy=invLenA*vyA+invLenB*vyB,vz=invLenA*vzA+invLenB*vzB,invLen=1/Math.sqrt(vx*vx+vy*vy+vz*vz),vnx=vx*invLen,vny=vy*invLen,vnz=vz*invLen;return 0<x1*vnx+y1*vny+z1*vnz?[vnx,vny,vnz]:[-vnx,-vny,-vnz]}var GLOBAL={vert:"// Perspective\r\nuniform mat4 uniProjection;\r\n// Rotation de la multiball.\r\nuniform mat4 uniRotation;\r\n// Translation.\r\nuniform vec4 uniTranslation;\r\n\r\n// Coordonn\xE9es du centre du mod\xE8le.\r\nattribute vec3 attPoint;\r\n// Vecteur normal en ce point.\r\nattribute vec3 attNormal;\r\n\r\nconst vec3 COLOR = vec3(0.1, 0.5, 0.86666666666666666);\r\nconst vec3 LIGHT = normalize(vec3(.5, -.5, -1));\r\n\r\nvarying vec3 varColor;\r\n\r\nfloat ramp(vec3 ray, float minValue, float maxValue) {\r\n    float diff = maxValue - minValue;\r\n    float alpha = 0.5 * (ray.z + 1.0);\r\n    return minValue + alpha * diff;\r\n}\r\n\r\nvoid main() {\r\n  // Rotation, translation et projection en perspective.\r\n  vec4 vertex = uniRotation * vec4( attPoint, 1 ) + uniTranslation;\r\n  gl_Position = uniProjection * vertex;\r\n\r\n  vec4 normal = uniRotation * vec4( attNormal, 1 );\r\n  vec3 ray = reflect(LIGHT, normal.xyz);\r\n  float lightPower = ramp(ray, 0.4, 1.5);\r\n\r\n  varColor = COLOR * lightPower;\r\n}\r\n",frag:"precision mediump float;\r\n\r\nvarying vec3 varColor;\r\n\r\nvoid main() {\r\n  gl_FragColor = vec4( varColor, 1.0 );\r\n}\r\n"};var M4=require("webgl.math").m4,Program=require("webgl.program"),Hilt=function(){function Hilt(gl){_classCallCheck(this,Hilt),this.gl=gl,this.prg=new Program(gl,{vert:GLOBAL.vert,frag:GLOBAL.frag}),this.buffVert=gl.createBuffer(),this.buffElem=gl.createBuffer();var _createMesh=createMesh(),arrayVert=_createMesh.arrayVert,arrayElem=_createMesh.arrayElem;this.arrayVert=arrayVert,this.arrayElem=arrayElem,this.countElem=arrayElem.length,gl.bindBuffer(gl.ARRAY_BUFFER,this.buffVert),gl.bufferData(gl.ARRAY_BUFFER,arrayVert,gl.STATIC_DRAW),gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,this.buffElem),gl.bufferData(gl.ELEMENT_ARRAY_BUFFER,arrayElem,gl.STATIC_DRAW),this.projection=M4.identity(),this.rotation=M4.identity(),this.translation=new Float32Array([0,-.1,-1,0])}return _createClass(Hilt,[{key:"paint",value:function paint(){var gl=this.gl,prg=this.prg,projection=this.projection,rotation=this.rotation,translation=this.translation,buffVert=this.buffVert,countElem=this.countElem;prg.use(),gl.bindBuffer(gl.ARRAY_BUFFER,this.buffVert),gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,this.buffElem),prg.$uniProjection=projection,prg.$uniRotation=rotation,prg.$uniTranslation=translation,gl.enable(gl.CULL_FACE),gl.enable(gl.DEPTH_TEST),gl.cullFace(gl.BACK),prg.bindAttribs(buffVert,"attPoint","attNormal"),gl.drawElements(gl.TRIANGLES,countElem,gl.UNSIGNED_SHORT,0)}},{key:"destroy",value:function destroy(){var gl=this.gl;gl.deleteBuffer(this.buffVert),gl.deleteBuffer(this.buffElem)}}]),Hilt}();module.exports=Hilt,module.exports._=function _(){return""}});
//# sourceMappingURL=saber-hilt.js.map