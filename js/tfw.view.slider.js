"use strict";

/** @module tfw.view.slider */
require('tfw.view.slider', function (require, module, exports) {
  var _ = function () {
    var D = {
      "en": {},
      "fr": {}
    },
        X = require("$").intl;

    function _() {
      return X(D, arguments);
    }

    _.all = D;
    return _;
  }();

  "use strict";
  /* exported CODE_BEHIND */


  var CODE_BEHIND = {
    onValueChanged: onValueChanged,
    onTapBack: onTapBack,
    onDragStart: onDragStart,
    onDrag: onDrag,
    onDragEnd: onDragEnd
  };

  var Dom = require("dom");
  /**
   * @this viewXJS
   * @param {integer} v - New value.
   * @returns {undefined}
   */


  function onValueChanged(v) {
    // If dragging is in progress, we don't want to mix a move and a translation.
    if (this._dragging) return;

    if (v < this.min) {
      this.value = this.min;
      return;
    }

    if (v > this.max) {
      this.value = this.max;
      return;
    }

    this.displayedValue = valueToDisplayedValue.call(this, v);
    moveToValue.call(this, v);
  }
  /**
   * @this ViewXJS
   * @param {object} evt - {}
   * @returns {undefined}
   */


  function onTapBack(evt) {
    this.value = xToValue.call(this, evt.x);
  }
  /**
   * Convert a X position into the nearest value.
   *
   * @this ViewXJS
   * @param   {float} x - X position relative to the View.
   * @returns {integer} The nearest integer value.
   */


  function xToValue(x) {
    var rect = this.$.getBoundingClientRect(),
        percent = x / rect.width,
        range = this.max - this.min,
        value = Math.floor(percent * range + 0.5);
    return this.min + this.step * Math.floor(value / this.step);
  }
  /**
   * Convert a value into X position relative to View.
   *
   * @this ViewXJS
   * @param   {integer} value - Current value.
   * @returns {float} X position.
   */


  function valueToX(value) {
    var rect = this.$.getBoundingClientRect(),
        percent = (value - this.min) / (this.max - this.min);
    return rect.width * percent;
  }
  /**
   * We store the Bounding Client Rect to prevent from querying it at every next drag.
   *
   * @this ViewXJS
   * @returns {undefined}
   */


  function onDragStart() {
    this._dragging = true;
    this._value = this.value;
    this._rect = this.$.getBoundingClientRect();
  }
  /**
   * Drag the button.
   *
   * @this ViewXJS
   * @param   {object} evt - `{ x, ... }`
   * @returns {undefined}
   */


  function onDrag(evt) {
    var rect = this._rect,
        x = valueToX.call(this, this._value),
        min = -x,
        max = rect.width - x,
        tx = clamp(evt.x - evt.x0, min, max),
        value = xToValue.call(this, x + tx);
    Dom.css(this.$elements.button, {
      transform: "translateX(".concat(tx, "px)")
    });
    this.displayedValue = valueToDisplayedValue.call(this, value);

    if (this.smooth) {
      this._dragging = true;
      this.value = value;
    }
  }
  /**
   * Enf of grag for the button. We can remove the temporaty translation.
   *
   * @this ViewXJS
   * @param   {object} evt - `{ x, ... }`
   * @returns {undefined}
   */


  function onDragEnd(evt) {
    this._dragging = false;
    var rect = this._rect,
        x = valueToX.call(this, this._value),
        min = -x,
        max = rect.width - x,
        tx = clamp(evt.x - evt.x0, min, max);
    Dom.css(this.$elements.button, {
      transform: "translateX(0px)"
    });
    this.value = xToValue.call(this, x + tx);
  }
  /**
   * Displayed value is a linear transformation of the real value.
   *
   * @this ViewXJS
   * @param   {integer} value [description]
   * @returns {float}       [description]
   */


  function valueToDisplayedValue(value) {
    return (this.factor * value + this.shift).toFixed(0);
  }
  /**
   * Move button to a position mapping the value.
   *
   * @this ViewXJS
   * @param   {integer} value - Value.
   * @returns {undefined}
   */


  function moveToValue(value) {
    var left = 100 * (value - this.min) / (this.max - this.min);
    Dom.css(this.$elements.button, {
      left: "".concat(left, "%")
    });
  }
  /**
   * Force a value to lay in a setAttributesAndRegisterElementsWithSpecialColors
   *
   * @param   {float} value - Value to clamp.
   * @param   {float} min   - Lower bound of the range.
   * @param   {float} max  - Upper bound of the range.
   * @returns {float} The clamped value.
   */


  function clamp(value, min, max) {
    if (value < min) return min;
    if (value > max) return max;
    return value;
  } //===============================
  // XJS:View autogenerated code.


  try {
    module.exports = function () {
      //--------------------
      // Dependent modules.
      var $ = require('dom');

      var PM = require('tfw.binding.property-manager');

      var Tag = require('tfw.view').Tag;

      var Link = require('tfw.binding.link');

      var View = require('tfw.view');

      ;

      var Converters = require('tfw.binding.converters'); //-------------------------------------------------------
      // Check if needed functions are defined in code behind.


      View.ensureCodeBehind(CODE_BEHIND, "onValueChanged", "onTapBack", "onDragStart", "onDrag", "onDragEnd"); //-------------------
      // Global functions.

      function defVal(args, attName, attValue) {
        return args[attName] === undefined ? attValue : args[attName];
      }

      ; //-------------------
      // Global variables.

      var conv_integer = Converters.get('integer');
      var conv_boolean = Converters.get('boolean');
      var conv_float = Converters.get('float');
      var conv_string = Converters.get('string'); //-------------------
      // Class definition.

      var ViewClass = function ViewClass(args) {
        try {
          if (typeof args === 'undefined') args = {};
          this.$elements = {};
          var that = this;
          var pm = PM(this); //--------------------
          // Create attributes.

          pm.create("value", {
            cast: conv_integer(0)
          });
          pm.create("min", {
            cast: conv_integer(0)
          });
          pm.create("max", {
            cast: conv_integer(0)
          });
          pm.create("step", {
            cast: conv_integer(0)
          });
          pm.create("smooth", {
            cast: conv_boolean
          });
          pm.create("shift", {
            cast: conv_float(0)
          });
          pm.create("factor", {
            cast: conv_float(0)
          });
          pm.create("displayedValue", {
            cast: conv_string
          }); //------------------
          // Create elements.

          var e_ = new Tag('DIV', ["class"]);
          var e_button = new Tag('DIV', ["class", "textcontent"]);
          this.$elements.button = e_button;
          $.add(e_, e_button); //-----------------------
          // Declare root element.

          Object.defineProperty(this, '$', {
            value: e_.$,
            writable: false,
            enumerable: false,
            configurable: false
          }); //---------
          // Events.

          View.events(e_, {
            "tap": CODE_BEHIND.onTapBack.bind(this)
          });
          View.events(e_button, {
            "dragstart": CODE_BEHIND.onDragStart.bind(this),
            "drag": CODE_BEHIND.onDrag.bind(this),
            "dragend": CODE_BEHIND.onDragEnd.bind(this)
          }); //-------
          // Links

          new Link({
            A: {
              obj: that,
              name: 'displayedValue'
            },
            B: {
              obj: e_button,
              name: 'textcontent'
            },
            name: "displayed-value > e_button/textcontent"
          }); //-----------------------
          // On attribute changed.

          pm.on("value", function (v) {
            try {
              CODE_BEHIND.onValueChanged.call(that, v);
            } catch (ex) {
              console.error('Exception in function behind "onValueChanged" of module "mod/tfw.view.slider.js" for attribute "value"!');
              console.error(ex);
            }
          }); //----------------------
          // Initialize elements.

          e_.class = "tfw-view-slider thm-ele2 thm-bgPD";
          e_button.class = "thm-ele4 thm-bgPL thm-fg"; //------------------------
          // Initialize attributes.

          pm.set("value", defVal(args, "value", 0));
          pm.set("min", defVal(args, "min", 0));
          pm.set("max", defVal(args, "max", 100));
          pm.set("step", defVal(args, "step", 1));
          pm.set("smooth", defVal(args, "smooth", false));
          pm.set("shift", defVal(args, "shift", 0));
          pm.set("factor", defVal(args, "factor", 1));
          pm.set("displayedValue", defVal(args, "displayedValue", 1));
          pm.fire("value");
          pm.fire("min");
          pm.fire("max");
          pm.fire("step");
          pm.fire("smooth");
          pm.fire("shift");
          pm.fire("factor");
          pm.fire("displayedValue");
          $.addClass(this, 'view', 'custom');
        } catch (ex) {
          console.error('mod/tfw.view.slider.js', ex);
          throw Error('Instantiation error in XJS of "mod/tfw.view.slider.js":\n' + ex);
        }
      };

      return ViewClass;
    }();
  } catch (ex) {
    throw Error('Definition error in XJS of "mod/tfw.view.slider.js"\n' + ex);
  }

  module.exports._ = _;
});
//# sourceMappingURL=tfw.view.slider.js.map